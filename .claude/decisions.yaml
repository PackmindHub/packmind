# AI Agent Implicit Decision Log
#
# This file captures implicit technical decisions and uncertainties encountered
# by AI agents during coding work. It helps track what architectural and design
# choices were made without explicit user guidance or documented standards.
#
# Review this file periodically to:
# - Understand what technical choices were made and why
# - Identify what uncertainties the AI had during implementation
# - Validate or question specific implementation decisions
# - Identify patterns that should become formal standards
# - Create explicit guidelines in CLAUDE.md
# - Add standards to Packmind
# - Use signal-capture to formalize good patterns into standards
#
# File is managed by the implicit-decision-capture skill.
# Schema: See .claude/skills/implicit-decision-capture/SKILL.md

# Example entries showing the skill in action:

- timestamp: 2026-01-09T17:30:00Z
  file: .claude/skills/implicit-decision-capture/SKILL.md
  context: 'Creating the implicit-decision-capture skill'
  category: 'architecture'
  question: 'Should the decisions.yaml file be tracked in git or gitignored?'
  decision: 'Track in git so teams can collaborate on context improvement'
  reasoning: 'This is team-wide context that everyone should review and improve, similar to CLAUDE.md'
  alternatives:
    - 'Gitignore it and keep it local to each developer'
    - 'Make it optional via configuration'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'skill-design'
    - 'collaboration'
    - 'git'

- timestamp: 2026-01-09T17:45:00Z
  file: .claude/skills/implicit-decision-capture/SKILL.md
  context: 'Creating the implicit-decision-capture skill'
  category: 'architecture'
  decision: 'Merge uncertainty-capture and decision-capture into a single skill'
  reasoning: 'Both skills captured the same concept (implicit decisions) with only minor differences. A single skill reduces cognitive overhead and eliminates the "log to both files" edge case.'
  alternatives:
    - 'Keep separate skills for questions vs decisions'
    - 'Create three-way merge with a new skill'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'skill-design'
    - 'simplification'
    - 'architecture'

- timestamp: 2026-01-19T14:30:00Z
  file: apps/cli/src/domain/constants/AgentPaths.ts
  context: 'Consolidating agent paths from multiple locations into centralized AgentConfiguration'
  category: 'architecture'
  question: 'Should CLI use the same agent names as CodingAgent type or keep backward compatibility with "github" naming?'
  decision: 'Maintain backward compatibility by keeping CLI AgentType as "claude" | "github" and mapping "github" to "copilot" internally'
  reasoning: 'CLI commands already exposed to users use "github" as the agent name. Changing this would be a breaking change for users. The mapping is done at import time from the centralized configuration.'
  alternatives:
    - 'Rename "github" to "copilot" in CLI (breaking change)'
    - 'Add both "github" and "copilot" as aliases'
    - 'Use CodingAgent type directly in CLI'
  impact: 'module'
  confidence: 'high'
  source: 'inference'
  tags:
    - 'backward-compatibility'
    - 'cli'
    - 'naming-conventions'
    - 'agent-configuration'

- timestamp: 2026-01-19T14:35:00Z
  file: packages/coding-agent/src/domain/AgentConfiguration.ts
  context: 'Creating centralized agent configuration for file paths and skill paths'
  category: 'architecture'
  question: 'Should agent skill paths return empty string or null for agents that do not support skills?'
  decision: 'Use null for agents without skill support in AGENT_SKILL_PATHS constant'
  reasoning: 'Null explicitly indicates "no skill support" vs empty string which could be ambiguous or indicate root directory. Makes it clear in API that callers need to check for null.'
  alternatives:
    - 'Return empty string for unsupported agents'
    - 'Omit unsupported agents from the Record (requires Partial<Record>)'
    - 'Throw error for unsupported agents'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'api-design'
    - 'null-handling'
    - 'type-safety'

- timestamp: 2026-01-20T12:00:00Z
  file: packages/integration-tests/src/test-setup.ts
  context: 'Fixing pre-existing lint errors while adding SSEEventPublisher mock'
  category: 'patterns'
  question: 'How should I fix unused parameter lint errors in a stub class implementing an interface?'
  decision: 'Use underscore prefix for unused parameters (_jobsOptions, _listeners, _jobId) combined with eslint-disable comments'
  reasoning: 'The SyncJob class is a test stub that implements IQueue interface. The unused parameters are required by the interface contract but not needed for the in-memory stub implementation. Using underscore prefix signals intent while eslint-disable silences the warnings without refactoring the interface.'
  alternatives:
    - 'Refactor IQueue interface to make parameters optional'
    - 'Remove parameters from method signatures (would break interface compliance)'
    - 'Add no-op usage of parameters just to silence linter'
  impact: 'local'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'testing'
    - 'typescript'
    - 'eslint'
    - 'interface-implementation'

- timestamp: 2026-01-20T14:30:00Z
  file: packages/coding-agent/src/infra/repositories/defaultSkillsDeployer/DefaultSkillsDeployer.ts
  context: 'Implementing deploySkillsCreator method to generate FileUpdates for skill-creator files'
  category: 'architecture'
  question: 'Should file contents be stored as constants in the source code or read from disk at runtime?'
  decision: 'Store file contents as string constants in the TypeScript source file'
  reasoning: 'Consistent with how other deployers work in this codebase (e.g., ClaudeDeployer generates content from constants/templates). This approach avoids filesystem dependencies at runtime and keeps the deployment logic self-contained.'
  alternatives:
    - 'Read files from disk at runtime using fs module'
    - 'Bundle files as assets and import them'
    - 'Fetch files from a remote source'
  impact: 'module'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'file-management'
    - 'deployment'
    - 'bundling'
    - 'coding-agent'

- timestamp: 2026-01-20T15:15:00Z
  file: packages/coding-agent/src/domain/repository/ICodingAgentDeployer.ts
  context: 'Adding deployDefaultSkills method to ICodingAgentDeployer interface'
  category: 'architecture'
  question: 'Should deployDefaultSkills be a required or optional method on ICodingAgentDeployer interface?'
  decision: 'Make deployDefaultSkills an optional method (deployDefaultSkills?())'
  reasoning: 'Not all deployers need to support default skills deployment. Making it optional allows deployers like PackmindDeployer or CursorDeployer to implement the interface without providing this capability, while ClaudeDeployer can implement it.'
  alternatives:
    - 'Make it required and have non-supporting deployers throw NotImplementedError'
    - 'Create a separate interface IDefaultSkillsDeployer'
    - 'Use type guards instead of optional method'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'interface-design'
    - 'optional-methods'
    - 'coding-agent'
    - 'typescript'

- timestamp: 2026-01-22T10:30:00Z
  file: jest.env-setup.ts
  context: 'Creating missing Jest env setup file to fix tests hanging'
  category: 'testing'
  question: 'What content should jest.env-setup.ts contain for preventing Winston memory leak?'
  decision: 'Set PACKMIND_LOG_LEVEL=silent before any modules load'
  reasoning: 'The comment in jest.preset.ts mentioned Winston memory leak prevention. Setting log level to silent before Winston loggers initialize prevents verbose logging in tests which can cause memory issues.'
  alternatives:
    - 'Mock Winston entirely in the setup file'
    - 'Disable Winston transports instead of setting log level'
    - 'Use NODE_ENV=test and handle in Winston config'
  impact: 'global'
  confidence: 'medium'
  source: 'inference'
  tags:
    - 'jest'
    - 'testing'
    - 'winston'
    - 'memory-optimization'

- timestamp: 2026-01-27T10:00:00Z
  file: CLAUDE.md
  context: 'Creating hierarchical CLAUDE.md structure across Packmind monorepo'
  category: 'architecture'
  question: 'What information hierarchy should CLAUDE.md files follow to avoid repetition?'
  decision: 'Use four-level hierarchy: root (monorepo-wide), apps/ (categorization), apps/*/  (app-specific), packages/ (all packages)'
  reasoning: 'Root covers concerns affecting entire monorepo (Nx, Node.js, TypeScript). apps/CLAUDE.md provides overview and categorization. Individual app files contain unique details. packages/CLAUDE.md covers all packages in one place rather than per-package files.'
  alternatives:
    - 'Flat structure with all information in root CLAUDE.md'
    - 'Per-package CLAUDE.md files in addition to apps/'
    - 'Two-level structure (root + per-app only)'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'documentation'
    - 'information-architecture'
    - 'monorepo'

- timestamp: 2026-01-27T10:15:00Z
  file: apps/CLAUDE.md
  context: 'Creating apps/CLAUDE.md to categorize applications'
  category: 'patterns'
  decision: 'Group 6 apps into 3 categories: Backend Services, Frontend & CLI, Testing & Documentation'
  reasoning: 'Logical grouping by primary function. Backend (api, mcp-server) both serve data. Frontend & CLI (frontend, cli) are user-facing. Testing & Docs (e2e-tests, doc) support development.'
  alternatives:
    - 'Alphabetical listing without categories'
    - 'Group by technology stack (Node.js vs React)'
    - 'Group by deployment type (server vs client)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'documentation'
    - 'categorization'
    - 'organization'

- timestamp: 2026-01-27T10:30:00Z
  file: apps/api/CLAUDE.md
  context: 'Creating individual app CLAUDE.md files'
  category: 'patterns'
  decision: 'Use consistent structure across all 6 app files: Architecture, Technologies, Main Commands, Key Patterns, Configuration, Testing, Related Documentation'
  reasoning: 'Provides predictable navigation for AI agents. Same sections in same order make it easy to quickly find specific information type across different apps.'
  alternatives:
    - 'Custom structure per app based on unique needs'
    - 'Minimal structure with just overview and commands'
    - 'More granular sections (separate DB, API, Auth sections)'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'documentation'
    - 'consistency'
    - 'structure'

- timestamp: 2026-01-27T10:45:00Z
  file: apps/api/CLAUDE.md
  context: 'Writing app CLAUDE.md files'
  category: 'naming'
  question: 'Should app CLAUDE.md files be ~40 lines or more comprehensive?'
  decision: 'Target 80-100 lines per app file with comprehensive details'
  reasoning: 'Provides enough context for AI agents to understand architecture, key patterns, and technologies without being overwhelming. All 6 files ended up 83-97 lines showing good consistency.'
  alternatives:
    - 'Keep minimal at ~40 lines with links to external docs'
    - 'Make comprehensive at 150+ lines with all details'
    - 'Variable length based on app complexity'
  impact: 'global'
  confidence: 'medium'
  source: 'ai-agent'
  tags:
    - 'documentation'
    - 'length'
    - 'detail-level'

- timestamp: 2026-01-27T11:00:00Z
  file: packages/CLAUDE.md
  context: 'Creating packages/CLAUDE.md'
  category: 'architecture'
  question: 'Should each package have its own CLAUDE.md file or one central file?'
  decision: 'Create single packages/CLAUDE.md with all 21 packages organized by category, no per-package files'
  reasoning: 'Packages are smaller units than apps. Per-package CLAUDE.md would be too granular (21 files). Central file provides overview and categories. Detailed package info exists in standards/AGENTS.md.'
  alternatives:
    - 'Create per-package CLAUDE.md for each of 21 packages'
    - 'Only document domain packages, skip infrastructure'
    - 'Group packages by creating CLAUDE.md per category folder'
  impact: 'global'
  confidence: 'high'
  source: 'inference'
  tags:
    - 'documentation'
    - 'granularity'
    - 'packages'

- timestamp: 2026-01-27T11:10:00Z
  file: packages/CLAUDE.md
  context: 'Organizing packages in packages/CLAUDE.md'
  category: 'patterns'
  decision: 'Organize 21 packages into 6 categories: Core Infrastructure, Domain Packages, Integration & Deployment, Language Analysis, Frontend, Supporting'
  reasoning: 'Groups packages by their primary purpose. Makes it easy to find packages related to specific concerns (domain logic vs infrastructure vs integrations).'
  alternatives:
    - 'Alphabetical listing without categories'
    - 'Group by dependency layers (domain, application, infrastructure)'
    - 'Group by technology (TypeORM packages, React packages, etc.)'
  impact: 'module'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'documentation'
    - 'categorization'
    - 'packages'

- timestamp: 2026-01-27T11:20:00Z
  file: CLAUDE.md
  context: 'Writing CLAUDE.md files across monorepo'
  category: 'styling'
  decision: 'Use imperative tone with ## headers and bullet points consistently across all files'
  reasoning: 'Imperative tone (e.g., "Build a project: nx build") is action-oriented and clearer than descriptive. Bullet points are scannable. ## headers provide clear structure.'
  alternatives:
    - 'Use descriptive prose paragraphs'
    - 'Use numbered lists instead of bullets'
    - 'Mix formats based on content type'
  impact: 'global'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'documentation'
    - 'writing-style'
    - 'formatting'

- timestamp: 2026-01-27T11:25:00Z
  file: apps/api/CLAUDE.md
  context: 'Writing app CLAUDE.md files'
  category: 'patterns'
  decision: 'Reference .claude/rules/ and other CLAUDE.md files rather than duplicating information'
  reasoning: 'Avoids repetition and keeps files focused on unique information. Single source of truth for standards in .claude/rules/. Cross-references guide AI agents to deeper information when needed.'
  alternatives:
    - 'Duplicate key information in each file for self-containment'
    - 'Inline all standards directly in app CLAUDE.md'
    - 'No references, make each file completely independent'
  impact: 'global'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'documentation'
    - 'dry-principle'
    - 'cross-references'

- timestamp: 2026-01-27T14:30:00Z
  file: apps/frontend/src/domain/accounts/components/CreateOrganizationForm.tsx
  context: 'Creating organization name form for sign-up flow'
  category: 'performance'
  question: 'How long should the debounce timeout be for organization name validation?'
  decision: 'Use 500ms debounce for organization name availability check'
  reasoning: 'Matches the existing debounce timeout used in SignUpWithOrganizationForm.tsx (line 59). Provides good balance between responsiveness and avoiding excessive API calls.'
  alternatives:
    - '300ms for faster feedback'
    - '1000ms to reduce API calls further'
    - 'No debounce, validate on blur instead'
  impact: 'local'
  confidence: 'high'
  source: 'pattern-matching'
  tags:
    - 'debounce'
    - 'validation'
    - 'ux'
    - 'api-calls'

- timestamp: 2026-01-27T14:35:00Z
  file: apps/frontend/src/domain/accounts/components/CreateOrganizationForm.tsx
  context: 'Creating organization name form for sign-up flow'
  category: 'performance'
  question: 'Should validation skip checking when the name matches the current organization name?'
  decision: 'Skip API validation call when trimmed name matches current organization.name'
  reasoning: 'Avoids unnecessary API call when user has not made changes or reverted to original name. This is a valid name by definition since it already exists for this organization.'
  alternatives:
    - 'Always validate against API regardless of current name'
    - 'Cache validation results'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'performance'
    - 'validation'
    - 'optimization'

- timestamp: 2026-01-27T14:40:00Z
  file: apps/frontend/src/domain/accounts/components/CreateOrganizationForm.tsx
  context: 'Creating organization name form for sign-up flow'
  category: 'patterns'
  question: 'What should happen when user clicks Continue without changing the organization name?'
  decision: 'Allow Continue without making API call when name unchanged, just call onSuccess()'
  reasoning: 'User may be satisfied with current name and want to proceed. Making them change it artificially would be poor UX. The form is about customization, not mandatory changes.'
  alternatives:
    - 'Require user to make changes before continuing'
    - 'Show confirmation that name was not changed'
    - 'Disable Continue button until name is different'
  impact: 'local'
  confidence: 'high'
  source: 'ai-agent'
  tags:
    - 'ux'
    - 'form-behavior'
    - 'optional-changes'
