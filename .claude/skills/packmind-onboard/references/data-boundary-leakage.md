# Data Boundary Leakage

Detect whether persistence/transport types leak into core logic.

## Search Patterns

### ORM Entity Indicators

```
# TypeORM
@Entity(
@Column(
@PrimaryGeneratedColumn
@ManyToOne
@OneToMany
@ManyToMany
@JoinColumn
@JoinTable
getRepository(
.createQueryBuilder(

# Prisma
prisma.
PrismaClient
@prisma/client

# Sequelize
@Table
@Column
Model.init
sequelize.define

# Mongoose
mongoose.Schema
mongoose.model
@Schema(
@Prop(

# SQLAlchemy
Base.metadata
Column(
relationship(
ForeignKey(

# ActiveRecord
belongs_to
has_many
has_one

# Hibernate/JPA
@Entity
@Table
@Column
@Id
@GeneratedValue
EntityManager
```

### Generated DTO/Type Indicators

```
# OpenAPI/Swagger generated
/* tslint:disable */
/* eslint-disable */
// Generated by
@ApiProperty(
swagger-typescript-api
openapi-generator
openapi-typescript

# Protocol Buffers
.proto
protobuf
google.protobuf
_pb.ts
_pb.js
_pb2.py

# GraphQL generated
__generated__
.graphql.ts
gql.tada
graphql-codegen
type.*Query
type.*Mutation
type.*Subscription

# gRPC
grpc.
@grpc/
_grpc_pb.ts

# Thrift
.thrift
```

### SQL Builder Patterns

```
# Raw SQL indicators in non-repository files
.query(`SELECT
.query("SELECT
.raw(`
.raw("
sql`
sql"
Knex
knex(
.select(
.where(
.join(
QueryBuilder
```

### Core Logic Locations

```
# Domain layer (should be clean)
src/domain/
src/core/
src/model/
src/entities/ (domain entities, not ORM)
src/value-objects/
src/aggregates/

# Application layer (should be clean)
src/application/
src/use-cases/
src/usecases/
src/services/ (application services)

# Acceptable locations for data types
src/infra/
src/infrastructure/
src/persistence/
src/repositories/
src/adapters/
src/api/
src/http/
src/graphql/
```

## Analysis Method

1. **Identify core logic files**: Domain, application layer files
2. **Scan for leakage indicators**: ORM decorators, generated type imports, SQL builders
3. **Check import sources**: Are domain files importing from infra/generated?
4. **Map type flow**: Where do ORM entities get used vs domain models?

## Leakage Categories

| Type                  | Leakage Pattern                         | Severity |
| --------------------- | --------------------------------------- | -------- |
| **ORM in domain**     | `@Entity` decorator in domain model     | High     |
| **Generated in core** | Import from `__generated__` in use case | High     |
| **SQL in service**    | Query builder in application service    | Medium   |
| **No mapping**        | ORM entity returned from use case       | Medium   |
| **Coupled tests**     | Tests depend on ORM entities directly   | Low      |

## Clean Architecture Expectation

```
Transport Types (HTTP/gRPC/GraphQL)
         ↓ map to
Application DTOs
         ↓ map to
Domain Models (pure, no decorators)
         ↓ map to
Persistence Entities (ORM)
```

## Reporting Threshold

Report only if:

- ≥1 leakage found in domain/application layer

## Insight Template

```
INSIGHT:
  id: LEAK-[n]
  title: "DATA LEAKAGE: [type] types found in [layer]"
  summary: "[N] [ORM|generated|SQL] usages in core logic."
  confidence: [high|medium|low]
  evidence:
    leakage_by_type:
      orm_entities:
        - path[:line] — @Entity in domain
      generated_types:
        - path[:line] — imports from __generated__
      sql_builders:
        - path[:line] — raw SQL in service
    clean_files:
      - path — properly isolated
```

## Standard/Command Suggestions

- **Standard**: "Domain models are persistence-agnostic" (no ORM decorators)
- **Standard**: "Map generated types at boundaries" (don't pass through)
- **Standard**: "SQL queries live in repositories only"
- **Command**: "Create domain model from ORM entity" (mapping guidance)
