# Schema / Generation Boundary Discipline

Detect where generated code is consumed and flag direct usage in core logic.

## Search Patterns

### OpenAPI / Swagger Generated

```
# Generated file markers
/* tslint:disable */
/* eslint-disable */
// This file was automatically generated
// Generated by openapi
// Auto-generated
@generated
DO NOT EDIT

# Generated directories
__generated__/
generated/
gen/
api-client/
openapi/

# Generator tools
openapi-generator
swagger-codegen
openapi-typescript
orval
swagger-typescript-api
NSwag
autorest
```

### Protocol Buffers / gRPC

```
# Proto files
*.proto
syntax = "proto3"
syntax = "proto2"

# Generated files
*_pb.ts
*_pb.js
*_pb2.py
*_pb.go
*.pb.h
*.pb.cc

# gRPC generated
*_grpc_pb.ts
*_grpc.pb.go
*_grpc_pb2.py

# Proto imports
google.protobuf
import "google/protobuf/
```

### GraphQL Generated

```
# Generated files
*.graphql.ts
*.generated.ts
__generated__/
gql/

# Codegen tools
graphql-codegen
gql.tada
graphql-request
urql

# Generated types
type.*Query
type.*Mutation
type.*Subscription
type.*Fragment
```

### Thrift / Avro / Other

```
# Thrift
*.thrift
gen-*

# Avro
*.avsc
*.avro

# JSON Schema
*.schema.json
json-schema-to-typescript
```

### Core Logic Locations (Should Not Import Generated)

```
# Domain layer
src/domain/
src/core/
src/model/
src/entities/
src/value-objects/
src/aggregates/

# Application layer
src/application/
src/use-cases/
src/usecases/
src/services/
```

### Acceptable Generated Usage Locations

```
# Infrastructure/Adapters
src/infra/
src/infrastructure/
src/adapters/
src/api/
src/http/
src/clients/
src/gateways/

# Mapping layer
src/mappers/
src/converters/
src/transformers/
```

## Analysis Method

1. **Identify generated code**: Find generated directories/files
2. **Build import graph**: Who imports from generated?
3. **Classify consumers**:
   - Adapter layer: Expected, acceptable
   - Core logic: Violation, needs mapping
4. **Check for mappers**: Are generated types mapped to domain types?
5. **Detect leakage**: Generated types in function signatures of core logic

## Boundary Discipline Levels

| Level | Description | Indicators |
|-------|-------------|------------|
| **Clean** | Generated types never in core | Mappers at boundaries |
| **Partial** | Some mapping, some leakage | Mixed usage |
| **Leaky** | Generated types throughout | No mapping layer |

## Violation Patterns

| Pattern | Location | Issue |
|---------|----------|-------|
| **Import in domain** | `domain/` imports `__generated__/` | Couples domain to external schema |
| **Return generated** | UseCase returns generated DTO | API contract leaks into app |
| **Accept generated** | Service accepts proto message | Tight coupling |
| **No mapping** | Generated → domain direct cast | Type confusion |

## Expected Architecture

```
External API/Service
       ↓
Generated Types (__generated__/)
       ↓
Adapter/Gateway (maps to domain)
       ↓
Domain Types (pure, owned)
       ↓
Use Cases / Services
```

## Reporting Threshold

Report only if:
- Generated code exists AND
- ≥1 import from core logic into generated

## Insight Template

```
INSIGHT:
  id: GEN-[n]
  title: "GENERATED CODE: [N] core logic files import generated types"
  summary: "Generated types from [source] leak into [layers]."
  confidence: [high|medium|low]
  evidence:
    generated_sources:
      - type: "[openapi|proto|graphql]"
        location: "path/"
        files: [N]
    violations:
      - path[:line] — [layer] imports from [generated]
    missing_mappers:
      - "[generated type] has no domain equivalent"
    acceptable_usage:
      - path — adapter correctly maps generated
```

## Standard/Command Suggestions

- **Standard**: "Map generated types at adapter boundaries"
- **Standard**: "Domain models never depend on generated schemas"
- **Standard**: "Create domain DTOs for external API contracts"
- **Command**: "Create mapper for generated type"
