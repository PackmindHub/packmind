import * as fs from 'fs/promises';
import * as path from 'path';
import { IContentWriteResult } from './ContentWriterService';
import { IProjectScanResult } from './ProjectScannerService';

export interface IAgentInstructionsWriteResult {
  filesCreated: string[];
  filesUpdated: string[];
  errors: string[];
}

export interface IAgentInstructionsService {
  generateEnhancementInstructions(
    writeResult: IContentWriteResult,
    scanResult: IProjectScanResult,
    projectPath: string,
  ): string;

  writeToAllAgentConfigs(
    projectPath: string,
    writeResult: IContentWriteResult,
    scanResult: IProjectScanResult,
  ): Promise<IAgentInstructionsWriteResult>;
}

export class AgentInstructionsService implements IAgentInstructionsService {
  private readonly SECTION_START = '<!-- packmind:enhance-start -->';
  private readonly SECTION_END = '<!-- packmind:enhance-end -->';

  async writeToAllAgentConfigs(
    projectPath: string,
    writeResult: IContentWriteResult,
    scanResult: IProjectScanResult,
  ): Promise<IAgentInstructionsWriteResult> {
    const result: IAgentInstructionsWriteResult = {
      filesCreated: [],
      filesUpdated: [],
      errors: [],
    };

    const instructions = this.generateEnhancementInstructions(
      writeResult,
      scanResult,
      projectPath,
    );

    // Define all agent config locations
    const agentConfigs = [
      { path: 'CLAUDE.md', format: 'markdown' },
      { path: '.cursorrules', format: 'markdown' },
      { path: '.windsurfrules', format: 'markdown' },
      { path: '.github/copilot-instructions.md', format: 'markdown' },
    ];

    for (const config of agentConfigs) {
      try {
        const written = await this.writeToAgentConfig(
          projectPath,
          config.path,
          instructions,
        );
        if (written.created) {
          result.filesCreated.push(config.path);
        } else if (written.updated) {
          result.filesUpdated.push(config.path);
        }
      } catch (error) {
        result.errors.push(
          `Failed to write to ${config.path}: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    }

    return result;
  }

  private async writeToAgentConfig(
    projectPath: string,
    configPath: string,
    instructions: string,
  ): Promise<{ created: boolean; updated: boolean }> {
    const fullPath = path.join(projectPath, configPath);
    const wrappedInstructions = `${this.SECTION_START}\n${instructions}\n${this.SECTION_END}`;

    // Ensure directory exists
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Check if file exists
    let existingContent = '';
    let fileExists = false;
    try {
      existingContent = await fs.readFile(fullPath, 'utf-8');
      fileExists = true;
    } catch {
      // File doesn't exist
    }

    if (fileExists) {
      // Check if our section already exists
      const sectionRegex = new RegExp(
        `${this.escapeRegex(this.SECTION_START)}[\\s\\S]*?${this.escapeRegex(this.SECTION_END)}`,
        'g',
      );

      if (sectionRegex.test(existingContent)) {
        // Replace existing section
        const newContent = existingContent.replace(
          sectionRegex,
          wrappedInstructions,
        );
        if (newContent !== existingContent) {
          await fs.writeFile(fullPath, newContent, 'utf-8');
          return { created: false, updated: true };
        }
        return { created: false, updated: false };
      } else {
        // Append section
        const newContent = `${existingContent}\n\n${wrappedInstructions}`;
        await fs.writeFile(fullPath, newContent, 'utf-8');
        return { created: false, updated: true };
      }
    } else {
      // Create new file
      await fs.writeFile(fullPath, wrappedInstructions, 'utf-8');
      return { created: true, updated: false };
    }
  }

  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  generateEnhancementInstructions(
    writeResult: IContentWriteResult,
    scanResult: IProjectScanResult,
    projectPath: string,
  ): string {
    const lines: string[] = [];

    lines.push('# Agent Enhancement Instructions');
    lines.push('');
    lines.push(
      'The following files were generated by the Packmind onboarding scanner. They contain basic scaffolding but need enhancement based on actual codebase analysis.',
    );
    lines.push('');
    lines.push('## Your Task');
    lines.push('');
    lines.push(
      'Analyze the codebase and enhance each generated file with specific, actionable content derived from actual code patterns found in this project.',
    );
    lines.push('');

    // Standards enhancement instructions
    if (writeResult.paths.standards.length > 0) {
      lines.push('## Standards to Enhance');
      lines.push('');
      lines.push(
        'For each standard file, analyze the codebase to find concrete examples and add specific rules:',
      );
      lines.push('');

      for (const standardPath of writeResult.paths.standards) {
        lines.push(`### \`${standardPath}\``);
        lines.push('');
        lines.push('**Enhancement steps:**');
        lines.push('1. Read the current file to understand its scope');
        lines.push(
          '2. Search the codebase for patterns related to this standard',
        );
        lines.push(
          '3. Extract 3-5 specific rules from actual code patterns you find',
        );
        lines.push(
          '4. Add concrete positive/negative examples from the codebase',
        );
        lines.push('5. Update the file with these enhanced rules');
        lines.push('');
      }
    }

    // Commands enhancement instructions
    if (writeResult.paths.commands.length > 0) {
      lines.push('## Commands to Enhance');
      lines.push('');
      lines.push(
        'For each command file, find real examples in the codebase and add detailed steps:',
      );
      lines.push('');

      for (const commandPath of writeResult.paths.commands) {
        lines.push(`### \`${commandPath}\``);
        lines.push('');
        lines.push('**Enhancement steps:**');
        lines.push(
          '1. Read the current file to understand the command purpose',
        );
        lines.push(
          '2. Find 2-3 existing implementations of this pattern in the codebase',
        );
        lines.push(
          '3. Extract the actual file structure and naming conventions used',
        );
        lines.push('4. Add real code snippets from the codebase as examples');
        lines.push(
          '5. Detail each step with specific file paths and code templates',
        );
        lines.push(
          '6. Add validation checkpoints based on project conventions',
        );
        lines.push('');
      }
    }

    // Skills enhancement instructions
    if (writeResult.paths.skills.length > 0) {
      lines.push('## Skills to Enhance');
      lines.push('');
      lines.push(
        'For each skill file, make it project-specific with real context:',
      );
      lines.push('');

      for (const skillPath of writeResult.paths.skills) {
        lines.push(`### \`${skillPath}\``);
        lines.push('');
        lines.push('**Enhancement steps:**');
        lines.push('1. Read the current skill content');
        lines.push('2. Explore the codebase structure relevant to this skill');
        lines.push(
          '3. Add specific file paths, patterns, and conventions from this project',
        );
        lines.push(
          '4. Include real commands and workflows used in this project',
        );
        lines.push(
          '5. Add troubleshooting tips based on the actual tech stack',
        );
        lines.push('');
      }
    }

    // Context about the project
    lines.push('## Project Context');
    lines.push('');
    lines.push(`**Project path:** \`${projectPath}\``);
    lines.push('');

    if (scanResult.languages.length > 0) {
      lines.push(`**Languages:** ${scanResult.languages.join(', ')}`);
    }
    if (scanResult.frameworks.length > 0) {
      lines.push(`**Frameworks:** ${scanResult.frameworks.join(', ')}`);
    }
    if (scanResult.tools.length > 0) {
      lines.push(`**Tools:** ${scanResult.tools.join(', ')}`);
    }
    if (scanResult.testFramework) {
      lines.push(`**Test framework:** ${scanResult.testFramework}`);
    }
    if (scanResult.packageManager) {
      lines.push(`**Package manager:** ${scanResult.packageManager}`);
    }
    if (scanResult.structure.isMonorepo) {
      lines.push('**Structure:** Monorepo');
    }

    lines.push('');
    lines.push('## Guidelines');
    lines.push('');
    lines.push(
      '- **Be specific:** Generic advice is not useful. Extract real patterns from this codebase.',
    );
    lines.push(
      '- **Use examples:** Include actual code snippets and file paths from the project.',
    );
    lines.push(
      '- **Stay concise:** Each rule or step should be actionable in one sentence.',
    );
    lines.push(
      '- **Verify patterns:** Only document patterns that appear consistently (3+ occurrences).',
    );
    lines.push(
      "- **Respect existing conventions:** Don't invent new patterns, document what exists.",
    );
    lines.push('');

    // Cleanup instructions
    lines.push('## Final Step: Cleanup');
    lines.push('');
    lines.push(
      'After enhancing all files above, remove these instructions from the agent config files:',
    );
    lines.push('');
    lines.push('1. Open each of these files:');
    lines.push('   - `CLAUDE.md`');
    lines.push('   - `.cursorrules`');
    lines.push('   - `.windsurfrules`');
    lines.push('   - `.github/copilot-instructions.md`');
    lines.push('');
    lines.push(
      '2. Delete the entire section between `<!-- packmind:enhance-start -->` and `<!-- packmind:enhance-end -->` (inclusive)',
    );
    lines.push('');
    lines.push(
      '3. If the file becomes empty after removal, delete the file entirely',
    );
    lines.push('');
    lines.push(
      "This cleanup ensures the enhancement instructions don't persist after the task is complete.",
    );
    lines.push('');

    return lines.join('\n');
  }
}
