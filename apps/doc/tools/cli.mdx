---
title: 'CLI: Command-Line Interface'
---

## Overview

The Packmind CLI provides the following commands:

- **`init`** - Initialize Packmind in your project (install skills + scan for patterns)
- **`login`** - Authenticate with your Packmind instance
- **`logout`** - Clear stored credentials
- **`whoami`** - Show current authentication status
- **`setup-mcp`** - Configure MCP for AI coding agents
- **`install`** - Download packages locally
- **`uninstall`** - Remove packages from your project
- **`onboard`** - Scan project and generate standards/commands/skills
- **`lint`** - Run detection programs (Enterprise only)
- **`skills add`** - Import skills into Packmind
- **`skills init`** - Install default Packmind skills locally
- **`skills list`** - List all skills in your organization
- **`standards create`** - Create a coding standard from a playbook file
- **`standards list`** - List all standards in your organization
- **`commands create`** - Create a reusable command from a playbook file
- **`commands list`** - List all commands in your organization
- **`packages create`** - Create a new package

## Installation

### One-click install (Recommended)

The easiest way to install and configure the Packmind CLI is using the one-click install available in the Packmind web interface.

**Where to find it:**

- During your first onboarding after creating an account
- Anytime in your **Account Settings** page

**What it does:**

1. Downloads and installs the Packmind CLI binary for your platform
2. Authenticates you automatically with your Packmind account
3. Configures the Packmind MCP servers for AI coding agents detected on your machine (Claude Code, Cursor, VS Code/GitHub Copilot)
4. Sets up your PATH environment variable

Simply copy the provided command and paste it into your terminal. The script handles everything automatically.

<Tip>
  **Why this is recommended** — The one-click install eliminates manual steps by
  combining installation, authentication, and MCP configuration in a single
  command. It also detects which AI coding agents you have installed and
  configures them automatically.
</Tip>

### Alternative: npm Package

<Note>**Node.js 22 or higher required**.</Note>

**Global Installation**:

```bash
npm install -g @packmind/cli
```

After installation, the `packmind-cli` command will be available globally.

**npx** (no installation required):

```bash
npx @packmind/cli install --list
```

This runs the CLI directly without installing it, always using the latest version.

### Alternative: Standalone Executables

Download the appropriate pre-built executable for your platform from the [GitHub Releases page](https://github.com/PackmindHub/packmind/releases?q=CLI&expanded=true).

**Available platforms:**

- **Linux x64**: `packmind-cli-linux-x64-{version}`
- **Linux arm64**: `packmind-cli-linux-arm64-{version}`
- **macOS arm64**: `packmind-cli-macos-arm64-{version}` (signed and notarized)
- **Windows x64**: `packmind-cli-windows-x64-{version}.exe`

**For Linux/macOS**, make the executable runnable:

```bash
chmod +x packmind-cli-*-{version}
```

**Optional**: Move to a directory in your PATH for easy access:

```bash
# Linux/macOS
sudo mv packmind-cli-*-{version} /usr/local/bin/packmind-cli

# Windows: Move to a directory in your PATH or run directly
```

<Tip>
  **Choosing an Installation Method** — Use **one-click install** for the
  simplest experience with automatic authentication and MCP setup. Use **npm
  global** if you want `packmind-cli` always available system-wide. Use **npx**
  for project-specific usage or testing without installation. Use **standalone
  executables** if you don't have Node.js installed or need a specific binary
  for your environment.
</Tip>

## Authentication

The CLI requires authentication to communicate with your Packmind instance.

### Login Command (Recommended)

The easiest way to authenticate is using the `login` command:

```bash
packmind-cli login
```

This will:

1. Open your browser to the Packmind login page
2. After you authenticate, automatically receive credentials
3. Store credentials securely in `~/.packmind/credentials.json`

**For self-hosted instances**, specify your host:

```bash
packmind-cli login --host https://your-packmind-instance.com
```

**Manual code entry** (if browser flow doesn't work):

You can also enter a login code manually from the web interface:

```bash
packmind-cli login --code YOUR_CODE_HERE
```

### Logout Command

To clear stored credentials:

```bash
packmind-cli logout
```

This removes the credentials file. If you also have `PACKMIND_API_KEY_V3` set as an environment variable, you'll need to unset it separately:

```bash
unset PACKMIND_API_KEY_V3
```

### Whoami Command

Check your current authentication status:

```bash
packmind-cli whoami
```

This displays:

- Your API key (masked)
- Connected host
- Organization name
- User name
- Credential expiration status

### Alternative: Environment Variable

You can also authenticate using an environment variable. This is useful for CI/CD pipelines or when you prefer not to store credentials in a file.

#### Getting Your API Key

1. Log in to your Packmind instance (Cloud or self-hosted)
2. Navigate to **Settings** (click your profile icon in the top right)
3. Scroll to the **CLI Authentication** section
4. Go to the **Environment Variable** tab
5. Click **Generate New Key** to create an API key (valid for 90 days)
6. Copy the generated key

#### Setting the API Key

Set the API key as an environment variable:

```bash
export PACKMIND_API_KEY_V3="your-api-key-here"
```

To make this permanent, add it to your shell configuration file (`~/.bashrc`, `~/.zshrc`, etc.):

```bash
echo 'export PACKMIND_API_KEY_V3="your-api-key-here"' >> ~/.zshrc
source ~/.zshrc
```

<Tip>
  **Credential Priority** — When both a credentials file and environment
  variable exist, the environment variable takes precedence.
</Tip>

## Init Command

Initialize Packmind in your project. This is the recommended first command to run when setting up Packmind in a new project.

### What Init Does

The init command performs two main actions:

1. **Installs default skills** - Including skill creator, standard creator, and onboarding skills
2. **Scans your project** - Detects languages, frameworks, tools, and generates project-specific content

### Basic Usage

```bash
packmind-cli init
```

This will:

1. Install Packmind's default skills to `.claude/skills/` (or equivalent for other agents)
2. Scan your project for technologies and patterns
3. Show a preview of generated standards, commands, and skills
4. Prompt for confirmation before writing files
5. Write generated content to `.packmind/` and `.claude/skills/`

### Flags

| Flag                    | Short | Description                                               |
| ----------------------- | ----- | --------------------------------------------------------- |
| `--dry-run`             | `-d`  | Preview generated content without writing files           |
| `--yes`                 | `-y`  | Skip confirmation prompts and proceed automatically       |
| `--skip-onboard`        |       | Only install default skills, skip project scanning        |
| `--skip-default-skills` |       | Only run onboarding, skip default skills installation     |
| `--push`                |       | Push generated standards and commands to Packmind backend |

**Examples:**

```bash
# Preview what would be generated
packmind-cli init --dry-run

# Auto-approve all prompts (for CI/CD)
packmind-cli init --yes

# Only install default skills
packmind-cli init --skip-onboard
```

### Generated Content

Based on your project's technologies, the init command may generate:

**Standards** (`.packmind/standards/`):

- Language-specific coding standards (TypeScript, Python, Java, etc.)
- Framework conventions (NestJS, React, Django, Spring Boot, etc.)
- Extracted rules from existing documentation

**Commands** (`.packmind/commands/`):

- Framework-specific workflows (create module, create component, etc.)

**Skills** (`.claude/skills/`):

- Project overview skill with technology stack summary
- Debugging workflows for your test framework
- Framework-specific debugging skills

<Tip>
  **First-time setup** — Run `packmind-cli init` after installing the CLI and
  logging in. It's the quickest way to get Packmind configured for your project.
</Tip>

## Onboard Command

Scan your project and generate standards, commands, and skills based on detected patterns. This is the same scanning functionality that runs during `init`, but can be run independently.

### When to Use Onboard

Use the onboard command when:

- You want to re-scan after project changes
- You've already installed default skills and just want to regenerate content
- You want to scan a different directory

### Basic Usage

```bash
packmind-cli onboard
```

### Flags

| Flag           | Short | Description                                               |
| -------------- | ----- | --------------------------------------------------------- |
| `--path <dir>` | `-p`  | Specify a different project path to scan                  |
| `--dry-run`    | `-d`  | Preview without writing files                             |
| `--yes`        | `-y`  | Skip confirmation prompts                                 |
| `--push`       |       | Push generated standards and commands to Packmind backend |

**Examples:**

```bash
# Scan a different directory
packmind-cli onboard --path ./other-project

# Preview what would be generated
packmind-cli onboard --dry-run
```

## Setup MCP Command

Configure MCP (Model Context Protocol) for your AI coding agents. This command automatically sets up the Packmind MCP server in your agents' configuration.

### Supported Agents

- **Claude Code** (`claude`)
- **Cursor** (`cursor`)
- **VS Code / GitHub Copilot** (`copilot`)

### Interactive Mode

Run without arguments to use interactive mode:

```bash
packmind-cli setup-mcp
```

This will:

1. Detect which AI agents are installed on your system
2. Present a selection prompt with detected agents pre-selected
3. Configure MCP for all selected agents

### Direct Mode

Specify target agents directly using the `--target` (or `-t`) flag:

```bash
packmind-cli setup-mcp --target claude
```

Configure multiple agents at once:

```bash
packmind-cli setup-mcp --target claude --target cursor
```

Or using the short form:

```bash
packmind-cli setup-mcp -t claude -t cursor -t copilot
```

<Tip>
  **Automatic Setup** — When you run `packmind-cli login`, the setup-mcp command
  runs automatically after successful authentication.
</Tip>

## Install Command

Download commands, standards, and skills from packages to your local machine.

### List Available Packages

```bash
packmind-cli install --list
```

### View Package Details

```bash
packmind-cli install --show <package-slug>
```

### View Workspace Status

See an overview of all `packmind.json` files and their installed packages across your workspace:

```bash
packmind-cli install --status
```

**Example output:**

```
Workspace packages status

packmind.json                        Packages
-----------------------------------------------------------------
./packmind.json                      generic
./apps/api/packmind.json             nestjs
./apps/frontend/packmind.json        frontend

3 unique packages currently installed.
```

This is useful for:

- Understanding what packages are installed across a monorepo
- Identifying empty or misconfigured `packmind.json` files (shown as `<no packages>`)
- Getting a quick summary of unique packages in your workspace

### Install Packages

```bash
packmind-cli install <package-slug> [additional-package-slugs...]
```

**Example:**

```bash
packmind-cli install backend frontend
```

This downloads all commands, standards, and skills from the specified packages and creates the appropriate files for your AI coding assistant.

<Note>
  **Default skills included** — When you install packages, Packmind's default
  skills (including the `packmind-create-skill` skill) are automatically
  installed alongside your package contents.
</Note>

### Recursive Install (Monorepos)

For monorepos or projects with multiple `packmind.json` files, use the recursive flag to install packages across all locations:

```bash
packmind-cli install -r
```

Or the long form:

```bash
packmind-cli install --recursive
```

This finds all `packmind.json` files in your git repository and installs their configured packages. After installation, a summary shows how many distributions were notified to Packmind.

<Tip>
  **AI Agent Rendering** — The files created by the install command depend on
  which AI agents are enabled in your organization settings. The CLI respects
  your organization's configured agents and creates instruction files
  accordingly (e.g., `AGENTS.md`, `.cursor/rules/`,
  `.github/copilot-instructions.md`). The `.packmind/` directory is always
  created regardless of your configuration. To configure which agents are
  enabled, see [Manage AI Agent Rendering](/administration/manage-ai-agents).
</Tip>

## Lint Command

<Info>
  **Enterprise Feature** — The lint command is only available in the
  **Enterprise** edition.
</Info>

Run detection programs against your codebase from the command line. This is useful for testing draft detection programs, verifying active programs, and integrating linting into your development workflow or CI/CD pipelines.

### How Lint Works

The CLI supports two linting modes:

**Local Mode** (recommended):

When you have `packmind.json` files in your project, the CLI uses them to determine which standards to check against. The CLI automatically searches for all `packmind.json` files in your project tree:

- **Ancestor configs**: Searches parent directories up to the Git repository root
- **Descendant configs**: Searches subdirectories from your current location

All standards from packages defined in these `packmind.json` files are included in the analysis scope. This allows different parts of your codebase to have different standards while inheriting common standards from parent directories.

To set up local linting, install packages using the `install` command. See [Distribute Standards and Commands](/getting-started/gs-distribute) for details.

**Deployment Mode**:

If no `packmind.json` files are found, the CLI falls back to using standards that have been deployed to your Git repository through the web interface. See [Deployment](/governance/distribution) to learn about this approach.

<Tip>
  **Priority** — When both local `packmind.json` files and deployments exist,
  the local configuration takes priority.
</Tip>

### Basic Usage

```bash
packmind-cli lint .
```

This command:

- Searches for `packmind.json` files in your project tree
- Loads detection programs from the standards defined in your packages
- Scans all files in the current directory (excluding `node_modules`, `dist`, and other common build folders)
- Runs all active detection programs
- Reports any violations found

### Specify a Path

Lint a specific directory or file:

```bash
packmind-cli lint src/
```

```bash
packmind-cli lint /path/to/your/project
```

### Limiting Scope with `--changed-files` and `--changed-lines`

When working on large codebases, you can focus the lint check on only the files or lines you've modified using the `--changed-files` and `--changed-lines` flags.

<Info>
  **Git Repository Required** — The `--changed-files` and `--changed-lines`
  flags requires your project to be in a Git repository.
</Info>

<Note>
  **Deprecated Option** — The `--diff` option is deprecated. Use
  `--changed-files` (equivalent to `--diff=files`) or `--changed-lines`
  (equivalent to `--diff=lines`) instead.
</Note>

**Check modified lines only:**

```bash
packmind-cli lint . --changed-lines
```

This analyzes only the specific lines you've changed, making it ideal for pre-commit hooks or reviewing your work before pushing.

**Check modified files only:**

```bash
packmind-cli lint . --changed-files
```

This analyzes all content in files you've modified, useful when you want full context but don't want to scan the entire codebase.

**Example workflow:**

```bash
# Make some changes to your code
git add .

# Check only what you changed
packmind-cli lint . --changed-lines

# If clean, commit
git commit -m "Your changes"
```

### Output Formats

Choose between human-readable and IDE-friendly output:

```bash
packmind-cli lint . --logger=ide
```

**Human-readable format** (default) shows:

- File paths with violations
- Line and character positions
- Rule identifiers
- Summary of total violations found

**IDE format** provides structured output that can be parsed by editors and CI/CD tools.

## Skills Command

Manage skills in your Packmind organization. Skills are reusable knowledge packages that AI coding assistants can discover and use.

### Initialize Default Skills

```bash
packmind-cli skills init
```

This command installs Packmind's default skills locally, including:

- **packmind-create-skill** — A skill that guides you through creating new skills with AI assistance
- **packmind-create-command** — A skill that guides you through creating reusable commands with AI assistance
- **packmind-create-standard** — A skill for creating coding standards via the CLI
- **packmind-onboard** — A skill for initializing Packmind in projects

After running this command, you can use these skills in your AI coding assistant to create new skills, commands, standards, or onboard projects interactively.

<Tip>
  **Automatic installation** — Default skills are also installed automatically
  when you run `packmind-cli init`, install a package with `packmind-cli
  install`, or when packages are distributed to your repository via the web app.
</Tip>

### List Skills

```bash
packmind-cli skills list
```

This command displays all skills in your Packmind organization, showing:

- **Slug** — The skill identifier
- **Name** — The display name
- **URL** — Direct link to view the skill in the web app
- **Description** — What the skill does

**Example output:**

```
Available skills:

- packmind-create-skill
    Name: Create Skill
    URL: https://app.packmind.com/org/my-org/space/global/skills/packmind-create-skill/files
    Description: Guide for creating effective skills...

- my-custom-skill
    Name: My Custom Skill
    URL: https://app.packmind.com/org/my-org/space/global/skills/my-custom-skill/files
    Description: Custom skill for my project...
```

### Add a Skill

```bash
packmind-cli skills add <path>
```

**Arguments:**

- `<path>` - Path to the skill directory containing skill files

**Example:**

```bash
packmind-cli skills add ./my-skill
```

This uploads the skill to your Packmind organization, making it available for distribution to repositories.

When uploading a skill that already exists, Packmind automatically compares the content:

- If changes are detected, a new version is created
- If the content is identical, no new version is created

See [Skills Management](/concepts/skills-management) for details on versioning.

## Standards Command

Create and manage coding standards from the command line.

### List Standards

```bash
packmind-cli standards list
```

This command displays all standards in your Packmind organization, showing:

- **Slug** — The standard identifier
- **Name** — The display name
- **URL** — Direct link to view the standard in the web app
- **Description** — What the standard covers

**Example output:**

```
Available standards:

- error-handling
    Name: Error Handling
    URL: https://app.packmind.com/org/my-org/space/global/standards/abc123/summary
    Description: Ensure errors are handled predictably...

- typescript-conventions
    Name: TypeScript Conventions
    URL: https://app.packmind.com/org/my-org/space/global/standards/def456/summary
    Description: TypeScript coding conventions...
```

### Create a Standard from a Playbook File

```bash
packmind-cli standards create <file>
```

**Arguments:**

- `<file>` - Path to a JSON playbook file containing the standard definition

**Example:**

```bash
packmind-cli standards create ./my-standard.json
```

This creates a new coding standard in your Packmind organization based on the playbook file.

### Playbook File Format

The standard-playbook file is a JSON file with the following structure:

```json
{
  "name": "Error Handling",
  "description": "Ensure errors are handled predictably with context and actionable feedback.",
  "scope": "Applies to all services and applications",
  "rules": [
    {
      "content": "Validate inputs at boundaries and fail fast"
    },
    {
      "content": "Preserve context when rethrowing errors",
      "examples": {
        "positive": "throw new PersistenceError('Save failed', { cause: e });",
        "negative": "throw new Error('Save failed');",
        "language": "TYPESCRIPT"
      }
    }
  ]
}
```

**Required fields:**

| Field         | Description                              |
| ------------- | ---------------------------------------- |
| `name`        | Standard name (displayed in the web app) |
| `description` | Context and purpose of the standard      |
| `scope`       | Where the standard applies               |
| `rules`       | Array of rules (at least one required)   |

**Rule fields:**

| Field      | Required | Description                                                                             |
| ---------- | -------- | --------------------------------------------------------------------------------------- |
| `content`  | Yes      | Rule description (max ~25 words, starts with action verb like "Use", "Avoid", "Prefer") |
| `examples` | No       | Code examples showing correct and incorrect usage                                       |

**Example fields (when provided):**

| Field      | Description                                                       |
| ---------- | ----------------------------------------------------------------- |
| `positive` | Code snippet showing correct implementation                       |
| `negative` | Code snippet showing incorrect implementation                     |
| `language` | Programming language (e.g., `TYPESCRIPT`, `JAVASCRIPT`, `PYTHON`) |

<Tip>
  **Workflow tip** — Use this command when you have standards defined as files
  in your repository or want to create standards without the MCP server.
</Tip>

## Commands Command

Create and manage reusable, multi-step workflow commands from the command line.

### List Commands

```bash
packmind-cli commands list
```

This command displays all commands in your Packmind organization, showing:

- **Slug** — The command identifier
- **Name** — The display name
- **URL** — Direct link to view the command in the web app

**Example output:**

```
Available commands:

- add-a-new-rest-endpoint
    Name: Add a New REST Endpoint
    URL: https://app.packmind.com/org/my-org/space/global/commands/abc123

- setup-database-migration
    Name: Setup Database Migration
    URL: https://app.packmind.com/org/my-org/space/global/commands/def456
```

### Create a Command from a Playbook File

```bash
packmind-cli commands create <file>
```

**Arguments:**

- `<file>` - Path to a JSON playbook file containing the command definition

**Example:**

```bash
packmind-cli commands create ./setup-api-endpoint.json
```

This creates a new command in your Packmind organization based on the playbook file.

### Playbook File Format

The command playbook file is a JSON file with the following structure:

```json
{
  "name": "Add a New REST Endpoint",
  "summary": "Step-by-step guide for adding a new REST endpoint with validation, tests, and documentation",
  "whenToUse": [
    "When adding a new API endpoint to the backend service",
    "When extending existing API functionality",
    "When creating endpoints for frontend integration"
  ],
  "contextValidationCheckpoints": [
    "Do you understand the business requirement for this endpoint?",
    "Do you know the request and response data structures?",
    "Is the endpoint's purpose clear to all team members?"
  ],
  "steps": [
    {
      "name": "Define the Route",
      "description": "Create the HTTP route with appropriate method (GET, POST, PUT, DELETE) and path in your API configuration"
    },
    {
      "name": "Implement the Handler",
      "description": "Write the handler function that processes the request and calls the appropriate use case or service",
      "codeSnippet": "// Example Express handler\napp.post('/api/users', async (req, res) => {\n  const user = await userService.create(req.body);\n  res.status(201).json(user);\n});"
    },
    {
      "name": "Add Input Validation",
      "description": "Validate request parameters and body data before processing"
    },
    {
      "name": "Write Tests",
      "description": "Create unit and integration tests covering success and error scenarios"
    },
    {
      "name": "Update API Documentation",
      "description": "Document the endpoint with request/response examples and parameter descriptions"
    }
  ]
}
```

### Command Identification

When you create a command, Packmind automatically generates a **slug** from the command name:

- **Name** (provided by you): `"Add a New REST Endpoint"`
- **Slug** (auto-generated): `"add-a-new-rest-endpoint"`

The slug is used for:

- File naming: `.claude/commands/packmind/add-a-new-rest-endpoint.md`
- AI agent invocation: `/add-a-new-rest-endpoint`
- Command identification and distribution

If a command with the same slug already exists in your space, Packmind appends a counter (e.g., `add-a-new-rest-endpoint-1`) to ensure uniqueness.

**Required fields:**

| Field                          | Description                                              |
| ------------------------------ | -------------------------------------------------------- |
| `name`                         | Command name (displayed in the web app)                  |
| `summary`                      | What the command does and why it's useful                |
| `whenToUse`                    | Array of scenarios when this command applies             |
| `contextValidationCheckpoints` | Array of validation questions to clarify before starting |
| `steps`                        | Array of step objects (at least one required)            |

**Step fields:**

| Field         | Required | Description                                    |
| ------------- | -------- | ---------------------------------------------- |
| `name`        | Yes      | Step title (e.g., "Define the Route")          |
| `description` | Yes      | Clear instructions for what to do in this step |
| `codeSnippet` | No       | Optional code example demonstrating the step   |

<Tip>
  **Workflow tip** — Use this command when you have commands defined as files in
  your repository or want to create commands without the MCP server. Commands
  are particularly useful for capturing multi-step development workflows that
  your team performs regularly.
</Tip>

## Packages Command

Create and manage packages from the command line.

### Create a Package

```bash
packmind-cli packages create <name>
```

**Arguments:**

- `<name>` - Name of the package to create

**Options:**

| Flag            | Short | Description                |
| --------------- | ----- | -------------------------- |
| `--description` | `-d`  | Description of the package |

**Example:**

```bash
packmind-cli packages create "Backend Standards"
```

With a description:

```bash
packmind-cli packages create "Backend Standards" -d "Standards and commands for backend development"
```

This creates a new empty package in your Packmind organization. After creation, you can add commands, standards, and skills to the package through the web interface or by using the `packageSlugs` parameter when creating items via MCP.

### Package Identification

When you create a package, Packmind automatically generates a **slug** from the package name:

- **Name** (provided by you): `"Backend Standards"`
- **Slug** (auto-generated): `"backend-standards"`

The slug is used for:

- Package installation: `packmind-cli install backend-standards`
- Package identification and distribution

If a package with the same slug already exists in your space, Packmind appends a counter (e.g., `backend-standards-1`) to ensure uniqueness.

## Related Documentation

- [Create your first command](/getting-started/gs-create-command): Learn how to create commands with AI assistance
- [Packages Management](/concepts/packages-management): Learn about organizing commands, standards, and skills into packages
- [Linter: Automated Detection](/linter/linter): Learn about how detection programs work
- [Standards Management](/concepts/standards-management): Create rules and add code examples
- [Skills Management](/concepts/skills-management): Create and manage reusable skills
