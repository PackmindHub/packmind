import React, { useState, useMemo } from 'react';
import {
  PMBox,
  PMVStack,
  PMHStack,
  PMField,
  PMFieldset,
  PMButton,
  PMInput,
  PMAlert,
  PMText,
} from '@packmind/ui';
import { Recipe } from '@packmind/types';
import slug from 'slug';
import { RECIPE_MESSAGES } from '../constants/messages';
import { MarkdownEditor } from '../../../shared/components/editor/MarkdownEditor';

export interface CommandFormData {
  name: string;
  content: string;
  slug?: string;
}

interface ICommandFormProps {
  mode: 'create' | 'edit';
  recipe?: Recipe;
  onCancel: () => void;
  onSubmit: (data: CommandFormData) => void;
  isPending: boolean;
  alert?: { type: 'success' | 'error'; message: string } | null;
}

export const CommandForm: React.FC<ICommandFormProps> = ({
  mode,
  recipe,
  onCancel,
  onSubmit,
  isPending,
  alert: externalAlert,
}) => {
  const [name, setName] = useState(recipe?.name ?? '');
  const [content, setContent] = useState(recipe?.content ?? '');
  const [customSlug, setCustomSlug] = useState('');
  const [alert, setAlert] = useState<{
    type: 'success' | 'error';
    message: string;
  } | null>(null);

  const displayAlert = externalAlert ?? alert;

  const autoGeneratedSlug = useMemo(() => {
    if (!name.trim()) return '';
    return slug(name.trim());
  }, [name]);

  const effectiveSlug = customSlug.trim()
    ? slug(customSlug.trim())
    : autoGeneratedSlug;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setAlert(null);

    if (!name.trim()) {
      setAlert({
        type: 'error',
        message: RECIPE_MESSAGES.validation.nameRequired,
      });
      return;
    }

    if (!content.trim()) {
      setAlert({
        type: 'error',
        message: RECIPE_MESSAGES.validation.contentRequired,
      });
      return;
    }

    const sanitizedSlug = customSlug.trim()
      ? slug(customSlug.trim())
      : undefined;
    onSubmit({
      name: name.trim(),
      content: content.trim(),
      slug: sanitizedSlug,
    });
  };

  const isFormValid = name.trim() && content.trim();
  const submitButtonText = mode === 'create' ? 'Create' : 'Update';
  const isEditMode = mode === 'edit';

  return (
    <PMBox as="form" onSubmit={handleSubmit}>
      {displayAlert && (
        <PMBox mb={4}>
          <PMAlert.Root status={displayAlert.type}>
            <PMAlert.Indicator />
            <PMAlert.Title>{displayAlert.message}</PMAlert.Title>
          </PMAlert.Root>
        </PMBox>
      )}
      <PMVStack gap={10} alignItems={'flex-start'}>
        <PMFieldset.Root>
          <PMFieldset.Content
            border={'solid 1px'}
            borderColor="border.primary"
            p={4}
          >
            <PMField.Root required>
              <PMField.Label>
                Name
                <PMField.RequiredIndicator />
              </PMField.Label>
              <PMInput
                placeholder="Enter command name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                disabled={isPending}
              />
              <PMField.HelperText>
                A descriptive name for your command (e.g., "Create React
                Component", "Setup Test File")
              </PMField.HelperText>
              <PMField.ErrorText />
            </PMField.Root>

            <PMField.Root>
              <PMField.Label>Slug</PMField.Label>
              <PMInput
                placeholder={autoGeneratedSlug || 'command-slug'}
                value={isEditMode ? (recipe?.slug ?? '') : customSlug}
                onChange={(e) => setCustomSlug(e.target.value)}
                disabled={isPending || isEditMode}
              />
              <PMField.HelperText>
                {isEditMode ? (
                  'The slug cannot be changed after creation'
                ) : (
                  <>
                    Command will be invoked as:{' '}
                    <PMText as="span" fontFamily="mono" fontWeight="medium">
                      /{effectiveSlug || 'command-slug'}
                    </PMText>
                  </>
                )}
              </PMField.HelperText>
              <PMField.ErrorText />
            </PMField.Root>

            <PMField.Root required>
              <PMField.Label>
                Content
                <PMField.RequiredIndicator />
              </PMField.Label>
              <PMBox width={'100%'}>
                <MarkdownEditor
                  defaultValue={content}
                  onMarkdownChange={(value) => setContent(value)}
                />
              </PMBox>
              <PMField.HelperText>
                The prompt or instructions that will be executed when this
                command is invoked
              </PMField.HelperText>
              <PMField.ErrorText />
            </PMField.Root>
          </PMFieldset.Content>
        </PMFieldset.Root>
      </PMVStack>

      <PMHStack
        marginTop={6}
        border={'solid 1px'}
        borderColor={'border.primary'}
        paddingY={4}
        justifyContent={'center'}
        backgroundColor={'background.secondary'}
        position={'sticky'}
        bottom={0}
      >
        <PMButton
          type="submit"
          variant="primary"
          disabled={!isFormValid || isPending}
          loading={isPending}
          size="lg"
        >
          {submitButtonText}
        </PMButton>
        <PMButton
          variant="secondary"
          onClick={onCancel}
          disabled={isPending}
          size="lg"
        >
          Cancel
        </PMButton>
      </PMHStack>
    </PMBox>
  );
};
