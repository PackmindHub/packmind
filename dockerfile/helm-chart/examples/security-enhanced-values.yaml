# Enhanced security configuration for Packmind Helm Chart
# This example demonstrates advanced security context configurations
# Based on Kubernetes security best practices

global:
  labels:
    environment: production
    security-profile: enhanced

# Global security contexts with enhanced settings
podSecurityContext:
  fsGroup: 2000
  runAsUser: 1000
  runAsGroup: 3000
  runAsNonRoot: true
  fsGroupChangePolicy: "Always"
  # SELinux configuration for environments that support it
  # seLinuxOptions:
  #   level: "s0:c123,c456"
  # Seccomp profile for enhanced container security
  seccompProfile:
    type: RuntimeDefault
  # Additional supplemental groups
  # supplementalGroups: [1000, 2000]

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
    # add: []  # Add specific capabilities if needed
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 3000
  # SELinux configuration for containers
  # seLinuxOptions:
  #   level: "s0:c123,c456"
  # Seccomp profile for containers
  seccompProfile:
    type: RuntimeDefault
  # For debugging/special cases, can override default /proc mount
  # procMount: Default

# API-specific security overrides
api:
  replicaCount: 2
  
  # Override global security contexts for API specifically
  podSecurityContext:
    fsGroup: 2000
    runAsUser: 1001  # Different user for API
    runAsGroup: 3000
    runAsNonRoot: true
  
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 3000
  
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi

# Frontend with different security requirements
frontend:
  replicaCount: 2
  
  # Frontend can use different security context
  podSecurityContext:
    fsGroup: 2000
    runAsUser: 1002  # Different user for frontend
    runAsGroup: 3000
    runAsNonRoot: true
  
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true  # Frontend can use read-only filesystem
    runAsNonRoot: true
    runAsUser: 1002
    runAsGroup: 3000
  
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 200m
      memory: 256Mi

# MCP Server with enhanced security
mcpServer:
  replicaCount: 2
  
  # MCP Server security context
  podSecurityContext:
    fsGroup: 2000
    runAsUser: 1003  # Different user for MCP
    runAsGroup: 3000
    runAsNonRoot: true
  
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1003
    runAsGroup: 3000
  
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi

# Network policies for enhanced security
networkPolicy:
  enabled: true
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
    - from:
      - namespaceSelector:
          matchLabels:
            name: monitoring
  egress:
    - to: []
      ports:
      - protocol: TCP
        port: 53
      - protocol: UDP
        port: 53
    - to:
      - namespaceSelector: {}
      ports:
      - protocol: TCP
        port: 5432  # PostgreSQL
      - protocol: TCP
        port: 6379  # Redis
    - to: []
      ports:
      - protocol: TCP
        port: 443   # HTTPS outbound
      - protocol: TCP
        port: 80    # HTTP outbound

# Use external databases for production security
postgresql:
  enabled: false
  external:
    databaseUrl: "postgres://packmind_user:secure_password@postgres-host:5432/packmind"

redis:
  enabled: false
  external:
    host: "redis-host.example.com"
    port: 6379

# Secure ingress configuration
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: secure.packmind.example.com
  tls:
    - secretName: packmind-tls
      hosts:
        - secure.packmind.example.com

# Use existing secrets for production
secrets:
  existing:
    apiSecret: "packmind-api-secrets"
    mcpSecret: "packmind-mcp-secrets"
