import { LogLevel, PackmindLogger } from '@packmind/logger';
import {
  AbstractMemberUseCase,
  MemberContext,
  PackmindEventEmitterService,
} from '@packmind/node-utils';
import {
  ArtifactsPulledEvent,
  FileUpdates,
  CodingAgent,
  IAccountsPort,
  ICodingAgentPort,
  IGitPort,
  IPullContentResponse,
  IRecipesPort,
  ISkillsPort,
  IStandardsPort,
  OrganizationId,
  PullContentCommand,
  RecipeVersion,
  SkillVersion,
  StandardVersion,
  Target,
  createOrganizationId,
  createUserId,
} from '@packmind/types';
import { PackageService } from '../services/PackageService';
import { PackmindConfigService } from '../services/PackmindConfigService';
import { NoPackageSlugsProvidedError } from '../../domain/errors/NoPackageSlugsProvidedError';
import { PackagesNotFoundError } from '../../domain/errors/PackagesNotFoundError';
import { RenderModeConfigurationService } from '../services/RenderModeConfigurationService';
import { IDistributionRepository } from '../../domain/repositories/IDistributionRepository';
import { TargetService } from '../services/TargetService';
import { parseGitRepoInfo } from './notifyDistribution/notifyDistribution.usecase';

const origin = 'PullContentUseCase';

const TRIAL_README_CONTENT = `# Packmind playbook

This directory contains coding standards and recipes for your project, generated by [Packmind](https://github.com/PackmindHub/packmind). Follow these guidelines to ensure consistency and quality across your codebase.

## How to contribute?
1. **Create an account**: Sign up to access the playbook management features and setup instructions. Ask your agent: \`Get the activation link for my Packmind account\`
2. **Prompt to capture knowledge**: here are examples of prompts you can use to capture knowledge:
    - "Generate a Packmind Standard describing our error handling in Node.js APIs."
    - "From the last commit, create a Packmind Recipe to refactor a React component to use Hooks instead of class components."
    - "Add a rule to enforce usage of the Button component instead of plain html buttons in the standard about our design system"
3. **Distribute**: Once you've created or edited a standard or recipe, review it for accuracy and completeness, then distribute it to make it available to your team. Learn more about [distributing Packmind playbooks](https://docs.packmind.com/gs-distribute).
`;

export class PullContentUseCase extends AbstractMemberUseCase<
  PullContentCommand,
  IPullContentResponse
> {
  constructor(
    private readonly packageService: PackageService,
    private readonly recipesPort: IRecipesPort,
    private readonly standardsPort: IStandardsPort,
    private readonly skillsPort: ISkillsPort,
    private readonly codingAgentPort: ICodingAgentPort,
    private readonly renderModeConfigurationService: RenderModeConfigurationService,
    accountsPort: IAccountsPort,
    private readonly eventEmitterService: PackmindEventEmitterService,
    private readonly gitPort: IGitPort,
    private readonly distributionRepository: IDistributionRepository,
    private readonly targetService: TargetService,
    private readonly packmindConfigService: PackmindConfigService = new PackmindConfigService(),
    logger: PackmindLogger = new PackmindLogger(origin, LogLevel.INFO),
  ) {
    super(accountsPort, logger);
    this.logger.info('PullContentUseCase initialized');
  }

  protected async executeForMembers(
    command: PullContentCommand & MemberContext,
  ): Promise<IPullContentResponse> {
    const { source = 'cli' } = command;

    this.logger.info('Pulling content for organization', {
      organizationId: command.organizationId,
      userId: command.userId,
      packagesSlugs: command.packagesSlugs,
    });

    // Validate that package slugs are provided (unless it's a removal-only operation)
    const isRemovalOnlyOperation =
      (!command.packagesSlugs || command.packagesSlugs.length === 0) &&
      command.previousPackagesSlugs &&
      command.previousPackagesSlugs.length > 0;

    if (
      !isRemovalOnlyOperation &&
      (!command.packagesSlugs || command.packagesSlugs.length === 0)
    ) {
      this.logger.error('Pull content failed: no package slugs provided', {
        organizationId: command.organizationId,
        userId: command.userId,
      });
      throw new NoPackageSlugsProvidedError();
    }

    try {
      // Get active coding agents: use command.agents if provided, otherwise fall back to org-level config
      let codingAgents;
      if (command.agents !== undefined) {
        codingAgents = command.agents;
        this.logger.info('Using agents from command (packmind.json override)', {
          codingAgents,
          organizationId: command.organizationId,
        });
      } else {
        codingAgents =
          await this.renderModeConfigurationService.resolveActiveCodingAgents(
            command.organization.id,
          );
        this.logger.info('Using organization-level render modes', {
          codingAgents,
          organizationId: command.organizationId,
        });
      }

      // Fetch packages and their artifacts (skip if removal-only operation)
      let recipeVersions: RecipeVersion[] = [];
      let standardVersions: StandardVersion[] = [];
      let skillVersions: SkillVersion[] = [];
      let packages: Awaited<
        ReturnType<PackageService['getPackagesBySlugsWithArtefacts']>
      > = [];

      if (!isRemovalOnlyOperation && command.packagesSlugs) {
        packages = await this.packageService.getPackagesBySlugsWithArtefacts(
          command.packagesSlugs,
          command.organization.id,
        );

        // Check if all requested slugs were found
        const foundSlugs = packages.map((pkg) => pkg.slug);
        const unknownSlugs = command.packagesSlugs.filter(
          (slug) => !foundSlugs.includes(slug),
        );

        if (unknownSlugs.length > 0) {
          this.logger.error('Pull content failed: unknown package slugs', {
            unknownSlugs,
            requestedSlugs: command.packagesSlugs,
            foundSlugs,
            organizationId: command.organizationId,
          });
          throw new PackagesNotFoundError(unknownSlugs);
        }

        this.logger.info('Found packages with relations', {
          count: packages.length,
          packagesSlugs: packages.map((p) => p.slug),
        });

        // Extract recipes, standards, and skills from packages
        const allRecipes = packages.flatMap((pkg) => pkg.recipes);
        const allStandards = packages.flatMap((pkg) => pkg.standards);
        const allSkills = packages.flatMap((pkg) => pkg.skills);

        // Deduplicate by ID (when multiple packages share the same artifact)
        const recipes = [...new Map(allRecipes.map((r) => [r.id, r])).values()];
        const standards = [
          ...new Map(allStandards.map((s) => [s.id, s])).values(),
        ];
        const skills = [...new Map(allSkills.map((s) => [s.id, s])).values()];

        this.logger.info('Extracted content from packages', {
          recipeCount: recipes.length,
          standardCount: standards.length,
          skillCount: skills.length,
        });

        // Get recipe versions for recipes
        const recipeVersionsPromises = recipes.map(async (recipe) => {
          const versions = await this.recipesPort.listRecipeVersions(recipe.id);
          versions.sort(
            (a: RecipeVersion, b: RecipeVersion) => b.version - a.version,
          );
          return versions[0];
        });

        recipeVersions = (await Promise.all(recipeVersionsPromises)).filter(
          (rv): rv is NonNullable<typeof rv> => rv !== null,
        );

        this.logger.info('Retrieved recipe versions', {
          count: recipeVersions.length,
        });

        // Get standard versions for standards
        const standardVersionsPromises = standards.map(async (standard) => {
          const versions = await this.standardsPort.listStandardVersions(
            standard.id,
          );
          versions.sort((a, b) => b.version - a.version);
          return versions[0];
        });

        standardVersions = (await Promise.all(standardVersionsPromises)).filter(
          (sv) => sv !== undefined,
        );

        this.logger.info('Retrieved standard versions', {
          count: standardVersions.length,
        });

        // Get skill versions for skills
        const skillVersionsPromises = skills.map(async (skill) => {
          const versions = await this.skillsPort.listSkillVersions(skill.id);
          versions.sort((a, b) => b.version - a.version);
          const latestVersion = versions[0];

          // Fetch skill files for this version
          if (latestVersion) {
            const files = await this.skillsPort.getSkillFiles(latestVersion.id);
            return { ...latestVersion, files };
          }
          return latestVersion;
        });

        skillVersions = (await Promise.all(skillVersionsPromises)).filter(
          (skv) => skv !== undefined,
        );

        this.logger.info('Retrieved skill versions', {
          count: skillVersions.length,
        });
      } else {
        this.logger.info(
          'Removal-only operation: skipping package fetching, will delete all artifacts from previous packages',
        );
      }

      // Process removed packages if previousPackagesSlugs provided
      let removedRecipeVersions: RecipeVersion[] = [];
      let removedStandardVersions: StandardVersion[] = [];
      let removedSkillVersions: SkillVersion[] = [];

      if (
        command.previousPackagesSlugs &&
        command.previousPackagesSlugs.length > 0
      ) {
        const removedPackageSlugs = this.computeRemovedPackages(
          command.previousPackagesSlugs,
          command.packagesSlugs ?? [],
        );

        if (removedPackageSlugs.length > 0) {
          this.logger.info('Detected removed packages', {
            removedPackageSlugs,
            count: removedPackageSlugs.length,
          });

          const result = await this.fetchArtifactsForRemovedPackages(
            removedPackageSlugs,
            command.organization.id,
          );
          removedRecipeVersions = result.recipeVersions;
          removedStandardVersions = result.standardVersions;
          removedSkillVersions = result.skillVersions;

          this.logger.info('Retrieved removed artifact versions', {
            removedRecipesCount: removedRecipeVersions.length,
            removedStandardsCount: removedStandardVersions.length,
            removedSkillsCount: removedSkillVersions.length,
          });
        }

        // Also check for updated packages (packages that are in both lists)
        // to detect artifacts that were removed from those packages
        const updatedPackageSlugs = this.computeUpdatedPackages(
          command.previousPackagesSlugs,
          command.packagesSlugs ?? [],
        );

        if (updatedPackageSlugs.length > 0) {
          this.logger.info(
            'Detected updated packages - checking for removed artifacts',
            {
              updatedPackageSlugs,
              count: updatedPackageSlugs.length,
            },
          );

          const previousResult = await this.fetchArtifactsForRemovedPackages(
            updatedPackageSlugs,
            command.organization.id,
          );

          // Add previous artifacts from updated packages to the removed lists
          // These will be filtered later by filterSharedArtifacts to exclude
          // artifacts that are still present in the current package content
          removedRecipeVersions = [
            ...removedRecipeVersions,
            ...previousResult.recipeVersions,
          ];
          removedStandardVersions = [
            ...removedStandardVersions,
            ...previousResult.standardVersions,
          ];
          removedSkillVersions = [
            ...removedSkillVersions,
            ...previousResult.skillVersions,
          ];

          this.logger.info(
            'Retrieved previous artifact versions from updated packages',
            {
              previousRecipesCount: previousResult.recipeVersions.length,
              previousStandardsCount: previousResult.standardVersions.length,
              previousSkillsCount: previousResult.skillVersions.length,
              totalRemovedRecipesCount: removedRecipeVersions.length,
              totalRemovedStandardsCount: removedStandardVersions.length,
              totalRemovedSkillsCount: removedSkillVersions.length,
            },
          );
        }
      }

      if (
        packages.length > 0 &&
        command.gitRemoteUrl &&
        command.gitBranch &&
        command.relativePath
      ) {
        const currentPackageIds = packages.map((p) => p.id as string);

        // Query distribution history for previously deployed artifacts
        const previouslyDeployedStandards =
          await this.findPreviouslyDeployedStandardVersions(
            command.organization.id,
            command.userId,
            command.gitRemoteUrl,
            command.gitBranch,
            command.relativePath,
            currentPackageIds,
          );

        if (previouslyDeployedStandards.length > 0) {
          this.logger.info(
            'Retrieved previously deployed standard versions from distribution history',
            { count: previouslyDeployedStandards.length },
          );

          // Add to removed standards - they'll be filtered later by filterSharedArtifacts
          // if they're still present in current package content
          removedStandardVersions = [
            ...removedStandardVersions,
            ...previouslyDeployedStandards,
          ];
        }

        const previouslyDeployedRecipes =
          await this.findPreviouslyDeployedRecipeVersions(
            command.organization.id,
            command.userId,
            command.gitRemoteUrl,
            command.gitBranch,
            command.relativePath,
            currentPackageIds,
          );

        if (previouslyDeployedRecipes.length > 0) {
          this.logger.info(
            'Retrieved previously deployed recipe versions from distribution history',
            { count: previouslyDeployedRecipes.length },
          );

          // Add to removed recipes - they'll be filtered later by filterSharedArtifacts
          // if they're still present in current package content
          removedRecipeVersions = [
            ...removedRecipeVersions,
            ...previouslyDeployedRecipes,
          ];
        }

        const previouslyDeployedSkills =
          await this.findPreviouslyDeployedSkillVersions(
            command.organization.id,
            command.userId,
            command.gitRemoteUrl,
            command.gitBranch,
            command.relativePath,
            currentPackageIds,
          );

        if (previouslyDeployedSkills.length > 0) {
          this.logger.info(
            'Retrieved previously deployed skill versions from distribution history',
            { count: previouslyDeployedSkills.length },
          );

          // Add to removed skills - they'll be filtered later by filterSharedArtifacts
          // if they're still present in current package content
          removedSkillVersions = [
            ...removedSkillVersions,
            ...previouslyDeployedSkills,
          ];
        }
      }

      // Initialize the merged file updates
      const mergedFileUpdates: FileUpdates = {
        createOrUpdate: [],
        delete: [],
      };

      // Track skill versions to delete for folder cleanup
      let skillVersionsToDelete: SkillVersion[] = [];
      let removedAgents: CodingAgent[] = [];
      let cleanupSkillVersions: SkillVersion[] = [];

      // Deploy artifacts for all coding agents using the unified method
      this.logger.info('Deploying artifacts for coding agents', {
        codingAgents,
      });

      const artifactFileUpdates =
        await this.codingAgentPort.deployArtifactsForAgents({
          recipeVersions,
          standardVersions,
          skillVersions,
          codingAgents,
        });

      this.logger.info('Generated artifact file updates', {
        createOrUpdateCount: artifactFileUpdates.createOrUpdate.length,
        deleteCount: artifactFileUpdates.delete.length,
      });

      this.mergeFileUpdates(mergedFileUpdates, artifactFileUpdates);

      // Generate deletion paths for removed artifacts (excluding shared ones)
      if (
        removedRecipeVersions.length > 0 ||
        removedStandardVersions.length > 0 ||
        removedSkillVersions.length > 0
      ) {
        const filterResult = this.filterSharedArtifacts(
          removedRecipeVersions,
          removedStandardVersions,
          removedSkillVersions,
          recipeVersions,
          standardVersions,
          skillVersions,
        );
        const recipeVersionsToDelete = filterResult.recipeVersionsToDelete;
        const standardVersionsToDelete = filterResult.standardVersionsToDelete;
        skillVersionsToDelete = filterResult.skillVersionsToDelete; // Assign to outer scope

        this.logger.info('Filtered shared artifacts from deletion', {
          originalRemovedRecipes: removedRecipeVersions.length,
          actualRecipesToDelete: recipeVersionsToDelete.length,
          originalRemovedStandards: removedStandardVersions.length,
          actualStandardsToDelete: standardVersionsToDelete.length,
          originalRemovedSkills: removedSkillVersions.length,
          actualSkillsToDelete: skillVersionsToDelete.length,
        });

        if (
          recipeVersionsToDelete.length > 0 ||
          standardVersionsToDelete.length > 0 ||
          skillVersionsToDelete.length > 0
        ) {
          const removalFileUpdates =
            await this.codingAgentPort.generateRemovalUpdatesForAgents({
              removed: {
                recipeVersions: recipeVersionsToDelete,
                standardVersions: standardVersionsToDelete,
                skillVersions: skillVersionsToDelete,
              },
              installed: {
                recipeVersions,
                standardVersions,
                skillVersions,
              },
              codingAgents,
            });

          this.logger.info('Generated removal file updates', {
            createOrUpdateCount: removalFileUpdates.createOrUpdate.length,
            deleteCount: removalFileUpdates.delete.length,
          });

          this.mergeFileUpdates(mergedFileUpdates, removalFileUpdates);
        }
      }

      if (command.gitRemoteUrl && command.gitBranch && command.relativePath) {
        try {
          const target = await this.findTargetFromGitInfo(
            command.organization.id,
            command.userId,
            command.gitRemoteUrl,
            command.gitBranch,
            command.relativePath,
          );

          if (target) {
            const previousRenderModes =
              await this.distributionRepository.findActiveRenderModesByTarget(
                command.organization.id,
                target.id,
              );

            const previousAgents =
              this.renderModeConfigurationService.mapRenderModesToCodingAgents(
                previousRenderModes,
              );

            const currentAgentSet = new Set(codingAgents);
            removedAgents = previousAgents.filter(
              (agent) => !currentAgentSet.has(agent),
            );

            if (removedAgents.length > 0) {
              const [
                activeRecipeVersions,
                activeStandardVersions,
                activeSkillVersions,
              ] = await Promise.all([
                this.distributionRepository.findActiveRecipeVersionsByTarget(
                  command.organization.id,
                  target.id,
                ),
                this.distributionRepository.findActiveStandardVersionsByTarget(
                  command.organization.id,
                  target.id,
                ),
                this.distributionRepository.findActiveSkillVersionsByTarget(
                  command.organization.id,
                  target.id,
                ),
              ]);

              cleanupSkillVersions = activeSkillVersions;

              const cleanupFileUpdates =
                await this.codingAgentPort.generateAgentCleanupUpdatesForAgents(
                  {
                    agents: removedAgents,
                    artifacts: {
                      recipeVersions: activeRecipeVersions,
                      standardVersions: activeStandardVersions,
                      skillVersions: activeSkillVersions,
                    },
                  },
                );

              this.mergeFileUpdates(mergedFileUpdates, cleanupFileUpdates);
            }
          }
        } catch (error) {
          this.logger.info('Skipping agent cleanup from render mode history', {
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }

      // Add README.md for trial users
      const user = await this.accountsPort.getUserById(
        createUserId(command.userId),
      );
      if (user?.trial) {
        this.logger.info('Adding README.md for trial user', {
          userId: command.userId,
        });
        mergedFileUpdates.createOrUpdate.push({
          path: '.packmind/README.md',
          content: TRIAL_README_CONTENT,
        });
      }

      // Add packmind.json config file
      const configFile =
        this.packmindConfigService.createConfigFileModification(
          command.packagesSlugs,
          undefined, // existingPackages - not needed, we already have all packages in packagesSlugs
          command.agents, // Pass agents to preserve them
        );
      mergedFileUpdates.createOrUpdate.push(configFile);

      this.logger.info('Successfully pulled content', {
        organizationId: command.organizationId,
        totalCreateOrUpdateCount: mergedFileUpdates.createOrUpdate.length,
        totalDeleteCount: mergedFileUpdates.delete.length,
      });

      this.eventEmitterService.emit(
        new ArtifactsPulledEvent({
          userId: createUserId(command.userId),
          organizationId: createOrganizationId(command.organizationId),
          packageSlugs: command.packagesSlugs,
          recipeCount: recipeVersions.length,
          standardCount: standardVersions.length,
          skillCount: skillVersions.length,
          source,
        }),
      );

      // Generate skill folders for agents that support skills
      // Includes BOTH installed AND removed skills for folder cleanup
      const skillFolderPaths =
        this.codingAgentPort.getSkillsFolderPathForAgents(codingAgents);

      // Combine installed and removed skills for folder cleanup
      const allSkillsForFolderCleanup = [
        ...skillVersions,
        ...skillVersionsToDelete,
      ];

      const skillFolders = codingAgents.flatMap((agent) => {
        const skillPath = skillFolderPaths.get(agent);
        if (!skillPath) return [];
        return allSkillsForFolderCleanup.map((sv) => `${skillPath}${sv.slug}`);
      });

      const removedAgentsSkillFolders =
        removedAgents.length > 0 && cleanupSkillVersions.length > 0
          ? (() => {
              const removedSkillFolderPaths =
                this.codingAgentPort.getSkillsFolderPathForAgents(
                  removedAgents,
                );
              return removedAgents.flatMap((agent) => {
                const skillPath = removedSkillFolderPaths.get(agent);
                if (!skillPath) return [];
                return cleanupSkillVersions.map(
                  (sv) => `${skillPath}${sv.slug}`,
                );
              });
            })()
          : [];

      const mergedSkillFolders = Array.from(
        new Set([...skillFolders, ...removedAgentsSkillFolders]),
      );

      this.logger.info('Generated skill folders', {
        installedSkillCount: skillVersions.length,
        removedSkillCount: skillVersionsToDelete.length,
        totalFolderCount: mergedSkillFolders.length,
      });

      return {
        fileUpdates: mergedFileUpdates,
        skillFolders: mergedSkillFolders,
      };
    } catch (error) {
      this.logger.error('Failed to pull content', {
        organizationId: command.organizationId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  private mergeFileUpdates(target: FileUpdates, source: FileUpdates): void {
    // Merge createOrUpdate files (avoid duplicates by path)
    const existingPaths = new Set(target.createOrUpdate.map((f) => f.path));
    for (const file of source.createOrUpdate) {
      if (!existingPaths.has(file.path)) {
        target.createOrUpdate.push(file);
        existingPaths.add(file.path);
      }
    }

    // Merge delete files (avoid duplicates by path)
    const existingDeletePaths = new Set(target.delete.map((f) => f.path));
    for (const file of source.delete) {
      if (!existingDeletePaths.has(file.path)) {
        target.delete.push(file);
        existingDeletePaths.add(file.path);
      }
    }
  }

  /**
   * Computes which package slugs have been removed by comparing
   * previous packages with current packages
   */
  private computeRemovedPackages(
    previousSlugs: string[],
    currentSlugs: string[],
  ): string[] {
    const currentSet = new Set(currentSlugs);
    return previousSlugs.filter((slug) => !currentSet.has(slug));
  }

  /**
   * Computes packages that are in both previous and current lists (updated packages).
   * These packages may have had artifacts added or removed.
   */
  private computeUpdatedPackages(
    previousSlugs: string[],
    currentSlugs: string[],
  ): string[] {
    const currentSet = new Set(currentSlugs);
    return previousSlugs.filter((slug) => currentSet.has(slug));
  }

  /**
   * Filters removed artifacts to exclude those still needed by remaining packages.
   * Compares by recipeId/standardId/skillId since the same artifact produces the same
   * file path regardless of which package it came from.
   */
  private filterSharedArtifacts(
    removedRecipeVersions: RecipeVersion[],
    removedStandardVersions: StandardVersion[],
    removedSkillVersions: SkillVersion[],
    remainingRecipeVersions: RecipeVersion[],
    remainingStandardVersions: StandardVersion[],
    remainingSkillVersions: SkillVersion[],
  ): {
    recipeVersionsToDelete: RecipeVersion[];
    standardVersionsToDelete: StandardVersion[];
    skillVersionsToDelete: SkillVersion[];
  } {
    const remainingRecipeIds = new Set(
      remainingRecipeVersions.map((rv) => rv.recipeId),
    );
    const remainingStandardIds = new Set(
      remainingStandardVersions.map((sv) => sv.standardId),
    );
    const remainingSkillIds = new Set(
      remainingSkillVersions.map((skv) => skv.skillId),
    );

    const recipeVersionsToDelete = removedRecipeVersions.filter(
      (rv) => !remainingRecipeIds.has(rv.recipeId),
    );
    const standardVersionsToDelete = removedStandardVersions.filter(
      (sv) => !remainingStandardIds.has(sv.standardId),
    );
    const skillVersionsToDelete = removedSkillVersions.filter(
      (skv) => !remainingSkillIds.has(skv.skillId),
    );

    return {
      recipeVersionsToDelete,
      standardVersionsToDelete,
      skillVersionsToDelete,
    };
  }

  /**
   * Fetches recipe, standard, and skill versions for the removed packages
   */
  private async fetchArtifactsForRemovedPackages(
    removedPackageSlugs: string[],
    organizationId: OrganizationId,
  ): Promise<{
    recipeVersions: RecipeVersion[];
    standardVersions: StandardVersion[];
    skillVersions: SkillVersion[];
  }> {
    // Fetch packages by slugs (they may not exist anymore, so we handle gracefully)
    const packages = await this.packageService.getPackagesBySlugsWithArtefacts(
      removedPackageSlugs,
      organizationId,
    );

    // Extract recipes, standards, and skills from removed packages
    const allRecipes = packages.flatMap((pkg) => pkg.recipes);
    const allStandards = packages.flatMap((pkg) => pkg.standards);
    const allSkills = packages.flatMap((pkg) => pkg.skills);

    // Deduplicate by ID (when multiple packages share the same artifact)
    const recipes = [...new Map(allRecipes.map((r) => [r.id, r])).values()];
    const standards = [...new Map(allStandards.map((s) => [s.id, s])).values()];
    const skills = [...new Map(allSkills.map((s) => [s.id, s])).values()];

    // Get recipe versions for removed recipes
    const recipeVersionsPromises = recipes.map(async (recipe) => {
      const versions = await this.recipesPort.listRecipeVersions(recipe.id);
      versions.sort(
        (a: RecipeVersion, b: RecipeVersion) => b.version - a.version,
      );
      return versions[0];
    });

    const recipeVersions = (await Promise.all(recipeVersionsPromises)).filter(
      (rv): rv is NonNullable<typeof rv> => rv !== null,
    );

    // Get standard versions for removed standards
    const standardVersionsPromises = standards.map(async (standard) => {
      const versions = await this.standardsPort.listStandardVersions(
        standard.id,
      );
      versions.sort((a, b) => b.version - a.version);
      return versions[0];
    });

    const standardVersions = (
      await Promise.all(standardVersionsPromises)
    ).filter((sv) => sv !== undefined);

    // Get skill versions for removed skills
    const skillVersionsPromises = skills.map(async (skill) => {
      const versions = await this.skillsPort.listSkillVersions(skill.id);
      versions.sort((a, b) => b.version - a.version);
      return versions[0];
    });

    const skillVersions = (await Promise.all(skillVersionsPromises)).filter(
      (skv) => skv !== undefined,
    );

    return { recipeVersions, standardVersions, skillVersions };
  }

  /**
   * Finds a target from git info by looking up the repository and path.
   * Shared logic used by all findPreviouslyDeployed* methods.
   */
  private async findTargetFromGitInfo(
    organizationId: OrganizationId,
    userId: string,
    gitRemoteUrl: string,
    gitBranch: string,
    relativePath: string,
  ): Promise<Target | null> {
    // Parse git remote URL to find repo
    const { owner, repo } = parseGitRepoInfo(gitRemoteUrl);

    // List all providers for the organization
    const providersResponse = await this.gitPort.listProviders({
      userId,
      organizationId,
    });

    // Find the git repo across all providers
    let gitRepoId: string | null = null;
    for (const provider of providersResponse.providers) {
      const repos = await this.gitPort.listRepos(provider.id);
      const matchingRepo = repos.find(
        (r) =>
          r.owner.toLowerCase() === owner.toLowerCase() &&
          r.repo.toLowerCase() === repo.toLowerCase() &&
          r.branch === gitBranch,
      );
      if (matchingRepo) {
        gitRepoId = matchingRepo.id;
        break;
      }
    }

    if (!gitRepoId) {
      this.logger.info(
        'Git repo not found in distribution history, cannot query previous deployments',
        { owner, repo, branch: gitBranch },
      );
      return null;
    }

    // Find the target by gitRepoId and relativePath (using TargetService)
    const targets = await this.targetService.getTargetsByGitRepoId(
      gitRepoId as ReturnType<typeof import('@packmind/types').createGitRepoId>,
    );

    // Normalize relativePath for comparison
    let normalizedPath = relativePath;
    if (!normalizedPath.startsWith('/')) {
      normalizedPath = '/' + normalizedPath;
    }
    if (!normalizedPath.endsWith('/')) {
      normalizedPath = normalizedPath + '/';
    }

    const target = targets.find((t) => t.path === normalizedPath);

    if (!target) {
      this.logger.info(
        'Target not found in distribution history, cannot query previous deployments',
        { gitRepoId, relativePath: normalizedPath },
      );
      return null;
    }

    return target;
  }

  /**
   * Finds previously deployed skill versions for a target by querying distribution history.
   * This is used to detect skills that were removed from packages between deployments.
   */
  private async findPreviouslyDeployedSkillVersions(
    organizationId: OrganizationId,
    userId: string,
    gitRemoteUrl: string,
    gitBranch: string,
    relativePath: string,
    currentPackageIds: string[],
  ): Promise<SkillVersion[]> {
    try {
      const target = await this.findTargetFromGitInfo(
        organizationId,
        userId,
        gitRemoteUrl,
        gitBranch,
        relativePath,
      );

      if (!target) {
        return [];
      }

      // Query previously deployed skill versions for this target and packages
      const previousSkillVersions =
        await this.distributionRepository.findActiveSkillVersionsByTargetAndPackages(
          organizationId,
          target.id,
          currentPackageIds as ReturnType<
            typeof import('@packmind/types').createPackageId
          >[],
        );

      this.logger.info(
        'Found previously deployed skill versions from distribution history',
        { targetId: target.id, count: previousSkillVersions.length },
      );

      return previousSkillVersions;
    } catch (error) {
      this.logger.info(
        'Failed to query distribution history for previous skill versions',
        { error: error instanceof Error ? error.message : String(error) },
      );
      return [];
    }
  }

  /**
   * Finds previously deployed standard versions for a target by querying distribution history.
   * This is used to detect standards that were removed from packages between deployments.
   */
  private async findPreviouslyDeployedStandardVersions(
    organizationId: OrganizationId,
    userId: string,
    gitRemoteUrl: string,
    gitBranch: string,
    relativePath: string,
    currentPackageIds: string[],
  ): Promise<StandardVersion[]> {
    try {
      const target = await this.findTargetFromGitInfo(
        organizationId,
        userId,
        gitRemoteUrl,
        gitBranch,
        relativePath,
      );

      if (!target) {
        return [];
      }

      // Query previously deployed standard versions for this target and packages
      const previousStandardVersions =
        await this.distributionRepository.findActiveStandardVersionsByTargetAndPackages(
          organizationId,
          target.id,
          currentPackageIds as ReturnType<
            typeof import('@packmind/types').createPackageId
          >[],
        );

      this.logger.info(
        'Found previously deployed standard versions from distribution history',
        { targetId: target.id, count: previousStandardVersions.length },
      );

      return previousStandardVersions;
    } catch (error) {
      this.logger.info(
        'Failed to query distribution history for previous standard versions',
        { error: error instanceof Error ? error.message : String(error) },
      );
      return [];
    }
  }

  /**
   * Finds previously deployed recipe versions for a target by querying distribution history.
   * This is used to detect recipes that were removed from packages between deployments.
   */
  private async findPreviouslyDeployedRecipeVersions(
    organizationId: OrganizationId,
    userId: string,
    gitRemoteUrl: string,
    gitBranch: string,
    relativePath: string,
    currentPackageIds: string[],
  ): Promise<RecipeVersion[]> {
    try {
      const target = await this.findTargetFromGitInfo(
        organizationId,
        userId,
        gitRemoteUrl,
        gitBranch,
        relativePath,
      );

      if (!target) {
        return [];
      }

      // Query previously deployed recipe versions for this target and packages
      const previousRecipeVersions =
        await this.distributionRepository.findActiveRecipeVersionsByTargetAndPackages(
          organizationId,
          target.id,
          currentPackageIds as ReturnType<
            typeof import('@packmind/types').createPackageId
          >[],
        );

      this.logger.info(
        'Found previously deployed recipe versions from distribution history',
        { targetId: target.id, count: previousRecipeVersions.length },
      );

      return previousRecipeVersions;
    } catch (error) {
      this.logger.info(
        'Failed to query distribution history for previous recipe versions',
        { error: error instanceof Error ? error.message : String(error) },
      );
      return [];
    }
  }
}
