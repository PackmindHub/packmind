{
  "name": "Java Best Practices",
  "summary": "Advanced, production-focused rules for core Java code handling failures, concurrency, IO, configuration, validation, and observability in typical backend and service applications.",
  "description": "This standard covers non-obvious, high-impact practices in core Java: robust resource lifecycles, error propagation, input validation, timeouts and retries, concurrency safety, logging correctness, configuration typing, immutability boundaries, and test determinism.",
  "scope": "**/*.java",
  "rules": [
    {
      "content": "Use timeouts on all blocking I/O and network calls via APIs that accept timeouts; set both connect and read/operation timeouts.",
      "examples": {
        "positive": "HttpClient client = HttpClient.newBuilder()\n    .connectTimeout(Duration.ofSeconds(2))\n    .build();\n\nHttpRequest req = HttpRequest.newBuilder(URI.create(url))\n    .timeout(Duration.ofSeconds(3))\n    .GET()\n    .build();\n\nHttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());",
        "negative": "HttpClient client = HttpClient.newHttpClient();\nHttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\nHttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());",
        "language": "JAVA"
      }
    },
    {
      "content": "Bound retries with max attempts and exponential backoff with jitter; retry only explicitly classified transient failures.",
      "examples": {
        "positive": "int maxAttempts = 4;\nDuration base = Duration.ofMillis(100);\nThreadLocalRandom rnd = ThreadLocalRandom.current();\n\nfor (int attempt = 1; attempt <= maxAttempts; attempt++) {\n  try {\n    return client.send(req, HttpResponse.BodyHandlers.ofString());\n  } catch (IOException e) {\n    if (attempt == maxAttempts) throw e;\n    long backoff = (long) (base.toMillis() * Math.pow(2, attempt - 1));\n    long jitter = rnd.nextLong(0, 50);\n    Thread.sleep(backoff + jitter);\n  }\n}\nthrow new AssertionError(\"unreachable\");",
        "negative": "while (true) {\n  try {\n    return client.send(req, HttpResponse.BodyHandlers.ofString());\n  } catch (Exception ignored) {\n    // retry forever\n  }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Preserve exception causes when rethrowing; wrap with a domain exception including the original Throwable as the cause.",
      "examples": {
        "positive": "try {\n  return Files.readString(path);\n} catch (IOException e) {\n  throw new UncheckedIOException(\"read failed: \" + path, e);\n}",
        "negative": "try {\n  return Files.readString(path);\n} catch (IOException e) {\n  throw new RuntimeException(\"read failed\");\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Restore interrupt status when catching InterruptedException; either rethrow or call Thread.currentThread().interrupt() and exit the blocking workflow.",
      "examples": {
        "positive": "try {\n  queue.take();\n} catch (InterruptedException e) {\n  Thread.currentThread().interrupt();\n  return;\n}",
        "negative": "try {\n  queue.take();\n} catch (InterruptedException e) {\n  // ignored\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Validate and normalize all external inputs at boundaries; reject invalid ranges, sizes, and formats before business logic.",
      "examples": {
        "positive": "static int parsePort(String raw) {\n  String s = Objects.requireNonNull(raw, \"port\").trim();\n  int p = Integer.parseInt(s);\n  if (p < 1 || p > 65535) throw new IllegalArgumentException(\"port\");\n  return p;\n}",
        "negative": "static int parsePort(String raw) {\n  return Integer.parseInt(raw);\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Return immutable or defensive copies from public APIs when exposing mutable state like arrays, lists, maps, or dates.",
      "examples": {
        "positive": "final class User {\n  private final List<String> roles;\n  User(List<String> roles) { this.roles = List.copyOf(roles); }\n  public List<String> getRoles() { return roles; }\n}",
        "negative": "final class User {\n  private final List<String> roles;\n  User(List<String> roles) { this.roles = roles; }\n  public List<String> getRoles() { return roles; }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Prefer immutable concurrency primitives for shared state; use Atomic* or Concurrent collections instead of unsynchronized mutable fields.",
      "examples": {
        "positive": "final class Metrics {\n  private final LongAdder requests = new LongAdder();\n  void inc() { requests.increment(); }\n  long count() { return requests.sum(); }\n}",
        "negative": "final class Metrics {\n  private long requests;\n  void inc() { requests++; }\n  long count() { return requests; }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Use try-with-resources for Closeable lifecycles that must close deterministically; include all resources in a single try header when possible.",
      "examples": {
        "positive": "try (InputStream in = Files.newInputStream(path);\n     OutputStream out = Files.newOutputStream(dest)) {\n  in.transferTo(out);\n}",
        "negative": "InputStream in = Files.newInputStream(path);\nOutputStream out = Files.newOutputStream(dest);\nin.transferTo(out);\nout.close();\nin.close();",
        "language": "JAVA"
      }
    },
    {
      "content": "Log structured context with placeholders; avoid string concatenation and avoid logging secrets; pass Throwable as the last parameter.",
      "examples": {
        "positive": "private static final Logger log = LoggerFactory.getLogger(MyService.class);\n\ntry {\n  service.call(userId);\n} catch (RuntimeException e) {\n  log.warn(\"call failed userId={} requestId={}\", userId, requestId, e);\n  throw e;\n}",
        "negative": "private static final Logger log = LoggerFactory.getLogger(MyService.class);\n\ntry {\n  service.call(userId);\n} catch (RuntimeException e) {\n  log.warn(\"call failed userId=\" + userId + \" password=\" + password + \" \" + e);\n  throw e;\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Parse configuration into typed values once at startup and pass as an immutable settings object; avoid repeated System.getenv/System.getProperty lookups.",
      "examples": {
        "positive": "record AppConfig(URI baseUri, Duration timeout) {\n  static AppConfig fromEnv() {\n    URI uri = URI.create(Objects.requireNonNull(System.getenv(\"BASE_URI\"), \"BASE_URI\"));\n    Duration t = Duration.ofMillis(Long.parseLong(System.getenv().getOrDefault(\"TIMEOUT_MS\", \"2000\")));\n    return new AppConfig(uri, t);\n  }\n}\n\nAppConfig cfg = AppConfig.fromEnv();",
        "negative": "URI uri = URI.create(System.getenv(\"BASE_URI\"));\nHttpClient client = HttpClient.newBuilder()\n    .connectTimeout(Duration.ofMillis(Long.parseLong(System.getenv(\"TIMEOUT_MS\"))))\n    .build();\n// later...\nlong ms = Long.parseLong(System.getenv(\"TIMEOUT_MS\"));",
        "language": "JAVA"
      }
    }
  ]
}
