{
  "name": "JavaScript Best Practices",
  "summary": "Apply these rules when writing production JavaScript that performs I/O, handles untrusted input, and runs in long-lived processes or services.",
  "description": "This standard covers high-impact JavaScript patterns for robustness and safety: reliable async control flow, error propagation, resource cleanup, input validation, network timeouts and retries, configuration handling, logging practices, concurrency-safe shared state, and test determinism. It focuses on pitfalls that commonly cause production incidents such as hung requests, swallowed errors, leaked handles, unsafe dynamic code execution, and flaky tests.",
  "scope": "**/*.js",
  "rules": [
    {
      "content": "Set explicit timeouts and cancellation for every network or IPC request using AbortController and per-request deadlines.",
      "examples": {
        "positive": "const controller = new AbortController();\nconst timeoutId = setTimeout(() => controller.abort(), 5000);\n\ntry {\n  const res = await fetch(url, { signal: controller.signal });\n  const data = await res.json();\n  return data;\n} finally {\n  clearTimeout(timeoutId);\n}",
        "negative": "const res = await fetch(url);\nreturn res.json();",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Retry only idempotent operations with bounded attempts, exponential backoff, and jitter; surface the final error without wrapping away the cause.",
      "examples": {
        "positive": "async function retry(fn, { attempts = 3, baseMs = 200 } = {}) {\n  let lastErr;\n  for (let i = 0; i < attempts; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      lastErr = e;\n      const jitter = Math.random() * 100;\n      const delay = baseMs * 2 ** i + jitter;\n      await new Promise(r => setTimeout(r, delay));\n    }\n  }\n  throw lastErr;\n}\n\nconst result = await retry(() => fetch(url, { method: 'GET', signal }), { attempts: 4 });",
        "negative": "while (true) {\n  try {\n    return await fetch(url, { method: 'POST' });\n  } catch {\n    // retry forever\n  }\n}",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Validate and normalize untrusted input at module boundaries using allowlists and type checks; reject extra fields and unexpected encodings.",
      "examples": {
        "positive": "function parseUser(payload) {\n  if (payload == null || typeof payload !== 'object') throw new TypeError('payload');\n  const { id, email } = payload;\n  if (typeof id !== 'string' || !/^[a-zA-Z0-9_-]{1,64}$/.test(id)) throw new TypeError('id');\n  if (typeof email !== 'string' || email.length > 254) throw new TypeError('email');\n  const extra = Object.keys(payload).filter(k => !['id', 'email'].includes(k));\n  if (extra.length) throw new TypeError('extra fields');\n  return { id, email: email.trim().toLowerCase() };\n}",
        "negative": "function parseUser(payload) {\n  return payload; // trusts shape, types, and extra fields\n}",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Avoid eval, Function, and dynamic import paths from untrusted data; use explicit dispatch maps for extensibility.",
      "examples": {
        "positive": "const handlers = {\n  sum: (a, b) => a + b,\n  mul: (a, b) => a * b\n};\n\nfunction run(op, a, b) {\n  const fn = handlers[op];\n  if (!fn) throw new Error('unknown op');\n  return fn(a, b);\n}",
        "negative": "function run(expr) {\n  return eval(expr);\n}\n\nasync function load(name) {\n  return import(`./plugins/${name}.js`);\n}",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Propagate errors with original cause using Error options or rethrow; avoid catch blocks that only log or return defaults.",
      "examples": {
        "positive": "async function loadConfig(path) {\n  try {\n    const text = await fs.promises.readFile(path, 'utf8');\n    return JSON.parse(text);\n  } catch (err) {\n    throw new Error(`loadConfig failed: ${path}`, { cause: err });\n  }\n}",
        "negative": "async function loadConfig(path) {\n  try {\n    const text = await fs.promises.readFile(path, 'utf8');\n    return JSON.parse(text);\n  } catch (err) {\n    console.error(err);\n    return {}; // hides failure\n  }\n}",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Release resources deterministically by awaiting stream completion and closing handles in finally; use pipeline/using patterns where available.",
      "examples": {
        "positive": "import { pipeline } from 'node:stream/promises';\nimport fs from 'node:fs';\n\nconst src = fs.createReadStream('in.txt');\nconst dst = fs.createWriteStream('out.txt');\n\ntry {\n  await pipeline(src, dst);\n} finally {\n  src.destroy();\n  dst.end();\n}",
        "negative": "const src = fs.createReadStream('in.txt');\nconst dst = fs.createWriteStream('out.txt');\nsrc.pipe(dst); // no awaited completion, no cleanup on error",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Avoid async callbacks in Array.forEach/map without awaiting; use for...of for sequencing or Promise.all with explicit concurrency limits.",
      "examples": {
        "positive": "for (const id of ids) {\n  await doWork(id);\n}\n\nawait Promise.all(ids.map(id => doWork(id)));",
        "negative": "ids.forEach(async id => {\n  await doWork(id);\n});\n// function returns before work finishes",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Use structured logging with stable keys and redaction; avoid logging secrets or whole objects containing credentials.",
      "examples": {
        "positive": "function logEvent(logger, event) {\n  const safe = {\n    requestId: event.requestId,\n    userId: event.userId,\n    action: event.action,\n    status: event.status\n  };\n  logger.info(safe);\n}\n\nlogEvent(console, { requestId, userId, action: 'login', status: 'failed', password: '***' });",
        "negative": "console.info('login failed', { requestId, userId, password, token, headers });",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Centralize configuration loading and freeze the exported config object; disallow runtime mutation and avoid reading process.env throughout the codebase.",
      "examples": {
        "positive": "function loadConfig(env = process.env) {\n  const port = Number(env.PORT ?? '3000');\n  if (!Number.isInteger(port) || port <= 0) throw new Error('PORT');\n  return Object.freeze({ port, nodeEnv: env.NODE_ENV ?? 'development' });\n}\n\nexport const config = loadConfig();",
        "negative": "export const config = { port: process.env.PORT || 3000 };\n\n// later\nconfig.port = 9999;\n\n// elsewhere\nconst port = process.env.PORT;",
        "language": "JAVASCRIPT"
      }
    },
    {
      "content": "Guard shared mutable state across async boundaries with explicit ownership, atomics, or a single-writer queue; avoid read-modify-write on shared objects.",
      "examples": {
        "positive": "let chain = Promise.resolve();\nconst state = { count: 0 };\n\nfunction increment() {\n  chain = chain.then(() => {\n    state.count += 1;\n  });\n  return chain;\n}\n\nawait Promise.all([increment(), increment(), increment()]);",
        "negative": "const state = { count: 0 };\n\nawait Promise.all([\n  (async () => { state.count = state.count + 1; })(),\n  (async () => { state.count = state.count + 1; })()\n]);",
        "language": "JAVASCRIPT"
      }
    }
  ]
}
