{
  "name": "Nuxt.js Best Practices",
  "summary": "Apply these rules when building Nuxt 3 apps with SSR, runtime config, and composables to keep data flow, caching, logging, and error handling production-safe.",
  "description": "This standard defines high-impact Nuxt 3 practices for server/client boundary safety, network resilience, runtime configuration, SSR caching, composable lifecycle management, consistent error handling, and test stability.",
  "scope": "**/*.vue,**/*.ts,**/*.js",
  "rules": [
    {
      "content": "Use useRuntimeConfig() for environment values; access private keys only on server code paths.",
      "examples": {
        "positive": "export default defineEventHandler(async (event) => {\n  const config = useRuntimeConfig()\n  const apiKey = config.private.upstreamApiKey\n  return await $fetch('https://upstream.example.com/data', {\n    headers: { authorization: `Bearer ${apiKey}` }\n  })\n})\n",
        "negative": "const config = useRuntimeConfig()\n// executed in client bundle\nconst apiKey = config.private.upstreamApiKey\nawait $fetch('/api/proxy', { headers: { authorization: `Bearer ${apiKey}` } })\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Set explicit timeout and abort handling on all $fetch calls using AbortController or timeout option.",
      "examples": {
        "positive": "const controller = new AbortController()\nconst t = setTimeout(() => controller.abort(), 5000)\ntry {\n  const data = await $fetch('https://api.example.com/items', { signal: controller.signal })\n  return data\n} finally {\n  clearTimeout(t)\n}\n",
        "negative": "const data = await $fetch('https://api.example.com/items')\nreturn data\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Implement bounded retries with backoff only for idempotent network operations; avoid retries for non-idempotent writes.",
      "examples": {
        "positive": "async function fetchWithRetry<T>(url: string, tries = 3): Promise<T> {\n  let lastErr: unknown\n  for (let i = 0; i < tries; i++) {\n    try {\n      return await $fetch<T>(url, { timeout: 5000 })\n    } catch (e) {\n      lastErr = e\n      await new Promise(r => setTimeout(r, 200 * 2 ** i))\n    }\n  }\n  throw lastErr\n}\n\nawait fetchWithRetry('/api/items')\n",
        "negative": "// retries a POST\nfor (let i = 0; i < 3; i++) {\n  await $fetch('/api/orders', { method: 'POST', body: { sku: 'x' } })\n}\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Validate and coerce request inputs at API boundaries using schema parsing before business logic.",
      "examples": {
        "positive": "import { z } from 'zod'\n\nconst Query = z.object({ q: z.string().min(1).max(50) })\n\nexport default defineEventHandler(async (event) => {\n  const query = Query.parse(getQuery(event))\n  return { q: query.q }\n})\n",
        "negative": "export default defineEventHandler(async (event) => {\n  const q = (getQuery(event) as any).q\n  return { q }\n})\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Centralize SSR fetch caching with useAsyncData keys and cache options; avoid per-render random keys.",
      "examples": {
        "positive": "const { data } = await useAsyncData(\n  'products:list',\n  () => $fetch('/api/products'),\n  { server: true }\n)\n",
        "negative": "const { data } = await useAsyncData(\n  `products:${Date.now()}`,\n  () => $fetch('/api/products')\n)\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Release external resources created in composables or plugins using onScopeDispose or Nitro close hooks.",
      "examples": {
        "positive": "export function useWs(url: string) {\n  const ws = new WebSocket(url)\n  onScopeDispose(() => ws.close())\n  return ws\n}\n",
        "negative": "export function useWs(url: string) {\n  // never closed\n  return new WebSocket(url)\n}\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Prefer per-request state in event.context over module-level singletons in server routes and plugins.",
      "examples": {
        "positive": "export default defineEventHandler(async (event) => {\n  event.context.requestId ||= crypto.randomUUID()\n  return { requestId: event.context.requestId }\n})\n",
        "negative": "let requestId: string\n\nexport default defineEventHandler(async () => {\n  requestId ||= crypto.randomUUID()\n  return { requestId }\n})\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Throw createError with statusCode and data from server handlers; avoid returning ad-hoc error objects.",
      "examples": {
        "positive": "export default defineEventHandler(async () => {\n  throw createError({ statusCode: 401, statusMessage: 'Unauthorized', data: { code: 'AUTH_REQUIRED' } })\n})\n",
        "negative": "export default defineEventHandler(async () => {\n  return { error: 'Unauthorized', code: 401 }\n})\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Log structured server events with request identifiers using consola or Nitro logger; avoid logging secrets and full payloads.",
      "examples": {
        "positive": "export default defineEventHandler(async (event) => {\n  const requestId = getHeader(event, 'x-request-id') ?? crypto.randomUUID()\n  consola.info({ requestId, route: event.path, msg: 'incoming request' })\n  return { ok: true }\n})\n",
        "negative": "export default defineEventHandler(async (event) => {\n  // dumps headers and cookies\n  console.log('headers', event.headers)\n  console.log('cookies', getCookie(event, 'session'))\n  return { ok: true }\n})\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Isolate tests from time, network, and Nuxt auto-imports by mocking $fetch, runtimeConfig, and timers per test.",
      "examples": {
        "positive": "import { describe, it, vi, expect, beforeEach } from 'vitest'\n\ndescribe('service', () => {\n  beforeEach(() => {\n    vi.stubGlobal('$fetch', vi.fn(async () => ({ ok: true })))\n    vi.useFakeTimers()\n  })\n\n  it('calls upstream', async () => {\n    const res = await $fetch('/api/ping')\n    expect(res).toEqual({ ok: true })\n  })\n})\n",
        "negative": "import { it, expect } from 'vitest'\n\nit('hits real network', async () => {\n  const res = await $fetch('https://api.example.com/ping')\n  expect(res).toBeTruthy()\n})\n",
        "language": "TYPESCRIPT"
      }
    }
  ]
}
