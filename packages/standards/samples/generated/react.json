{
  "name": "React Best Practices",
  "description": "Advanced React standards for preventing production bugs, performance regressions, security issues, and test flakiness in modern React applications.",
  "scope": "React source files",
  "rules": [
    {
      "content": "Include AbortController cancellation in every async effect and clean up pending requests on unmount or dependency changes.",
      "examples": {
        "positive": "import React, { useEffect, useState } from \"react\";\n\nexport function UserCard({ id }: { id: string }) {\n  const [user, setUser] = useState<{ name: string } | null>(null);\n\n  useEffect(() => {\n    const ac = new AbortController();\n\n    (async () => {\n      const res = await fetch(`/api/users/${id}`, { signal: ac.signal });\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\n      setUser(await res.json());\n    })().catch((e) => {\n      if ((e as any).name !== \"AbortError\") console.error(e);\n    });\n\n    return () => ac.abort();\n  }, [id]);\n\n  return <div>{user?.name ?? \"Loading...\"}</div>;\n}\n",
        "negative": "import React, { useEffect, useState } from \"react\";\n\nexport function UserCard({ id }: { id: string }) {\n  const [user, setUser] = useState<any>(null);\n\n  useEffect(() => {\n    fetch(`/api/users/${id}`)\n      .then((r) => r.json())\n      .then(setUser);\n  }, [id]);\n\n  return <div>{user?.name ?? \"Loading...\"}</div>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Set explicit timeouts for network calls and wrap fetch with a shared client that enforces them.",
      "examples": {
        "positive": "export async function fetchWithTimeout(input: RequestInfo, init: RequestInit = {}, ms = 10_000) {\n  const ac = new AbortController();\n  const t = setTimeout(() => ac.abort(), ms);\n  try {\n    return await fetch(input, { ...init, signal: ac.signal });\n  } finally {\n    clearTimeout(t);\n  }\n}\n\n// usage\nawait fetchWithTimeout(\"/api/search?q=react\");\n",
        "negative": "// usage\nawait fetch(\"/api/search?q=react\");\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Retry only idempotent requests with bounded attempts and backoff; avoid retrying non-idempotent POSTs by default.",
      "examples": {
        "positive": "const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport async function getWithRetry(url: string, attempts = 3) {\n  let last: unknown;\n  for (let i = 0; i < attempts; i++) {\n    try {\n      const res = await fetch(url);\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\n      return res;\n    } catch (e) {\n      last = e;\n      await sleep(200 * 2 ** i);\n    }\n  }\n  throw last;\n}\n\nawait getWithRetry(\"/api/catalog\");\n",
        "negative": "async function postWithRetry(url: string, body: unknown) {\n  for (let i = 0; i < 5; i++) {\n    await fetch(url, { method: \"POST\", body: JSON.stringify(body) });\n  }\n}\n\npostWithRetry(\"/api/orders\", { sku: \"x\" });\n",
        "language": "TYPESCRIPT"
      }
    },
    {
      "content": "Validate and sanitize untrusted strings before rendering with dangerouslySetInnerHTML; use a vetted HTML sanitizer.",
      "examples": {
        "positive": "import DOMPurify from \"dompurify\";\n\nexport function RichText({ html }: { html: string }) {\n  const safe = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });\n  return <div dangerouslySetInnerHTML={{ __html: safe }} />;\n}\n",
        "negative": "export function RichText({ html }: { html: string }) {\n  return <div dangerouslySetInnerHTML={{ __html: html }} />;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Keep derived state out of useState; compute it from props/state with memoization when expensive.",
      "examples": {
        "positive": "import React, { useMemo } from \"react\";\n\nexport function Totals({ items }: { items: Array<{ price: number; qty: number }> }) {\n  const total = useMemo(\n    () => items.reduce((sum, i) => sum + i.price * i.qty, 0),\n    [items]\n  );\n  return <div>Total: {total}</div>;\n}\n",
        "negative": "import React, { useEffect, useState } from \"react\";\n\nexport function Totals({ items }: { items: Array<{ price: number; qty: number }> }) {\n  const [total, setTotal] = useState(0);\n  useEffect(() => {\n    setTotal(items.reduce((sum, i) => sum + i.price * i.qty, 0));\n  }, [items]);\n  return <div>Total: {total}</div>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Prefer functional state updates when next state depends on previous state; avoid reading stale state from closures.",
      "examples": {
        "positive": "import React, { useState } from \"react\";\n\nexport function Counter() {\n  const [n, setN] = useState(0);\n  const incTwice = () => {\n    setN((p) => p + 1);\n    setN((p) => p + 1);\n  };\n  return <button onClick={incTwice}>{n}</button>;\n}\n",
        "negative": "import React, { useState } from \"react\";\n\nexport function Counter() {\n  const [n, setN] = useState(0);\n  const incTwice = () => {\n    setN(n + 1);\n    setN(n + 1);\n  };\n  return <button onClick={incTwice}>{n}</button>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Avoid mutating objects or arrays held in state; create new references for updates at every changed level.",
      "examples": {
        "positive": "import React, { useState } from \"react\";\n\ntype Item = { id: string; done: boolean };\n\nexport function List() {\n  const [items, setItems] = useState<Item[]>([{ id: \"a\", done: false }]);\n\n  const toggle = (id: string) =>\n    setItems((prev) => prev.map((i) => (i.id === id ? { ...i, done: !i.done } : i)));\n\n  return <button onClick={() => toggle(\"a\")}>{String(items[0].done)}</button>;\n}\n",
        "negative": "import React, { useState } from \"react\";\n\ntype Item = { id: string; done: boolean };\n\nexport function List() {\n  const [items, setItems] = useState<Item[]>([{ id: \"a\", done: false }]);\n\n  const toggle = (id: string) => {\n    const item = items.find((i) => i.id === id)!;\n    item.done = !item.done;\n    setItems(items);\n  };\n\n  return <button onClick={() => toggle(\"a\")}>{String(items[0].done)}</button>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Avoid unstable dependencies in useEffect/useMemo; memoize callbacks and objects passed to dependency arrays.",
      "examples": {
        "positive": "import React, { useCallback, useEffect } from \"react\";\n\nexport function Search({ query }: { query: string }) {\n  const run = useCallback(async (q: string) => {\n    await fetch(`/api/search?q=${encodeURIComponent(q)}`);\n  }, []);\n\n  useEffect(() => {\n    run(query);\n  }, [run, query]);\n\n  return null;\n}\n",
        "negative": "import React, { useEffect } from \"react\";\n\nexport function Search({ query }: { query: string }) {\n  const run = async (q: string) => {\n    await fetch(`/api/search?q=${encodeURIComponent(q)}`);\n  };\n\n  useEffect(() => {\n    run(query);\n  }, [run, query]);\n\n  return null;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Place side effects and subscriptions in useEffect cleanup; close sockets, remove listeners, and clear intervals deterministically.",
      "examples": {
        "positive": "import React, { useEffect, useState } from \"react\";\n\nexport function Clock() {\n  const [now, setNow] = useState(Date.now());\n\n  useEffect(() => {\n    const id = window.setInterval(() => setNow(Date.now()), 1000);\n    return () => window.clearInterval(id);\n  }, []);\n\n  return <time>{new Date(now).toISOString()}</time>;\n}\n",
        "negative": "import React, { useEffect, useState } from \"react\";\n\nexport function Clock() {\n  const [now, setNow] = useState(Date.now());\n\n  useEffect(() => {\n    window.setInterval(() => setNow(Date.now()), 1000);\n  }, []);\n\n  return <time>{new Date(now).toISOString()}</time>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Isolate React tests from timers, network, and randomness; use fake timers, request mocking, and deterministic seeds per test.",
      "examples": {
        "positive": "import { afterEach, beforeEach, it, expect, vi } from \"vitest\";\n\nbeforeEach(() => {\n  vi.useFakeTimers();\n  vi.stubGlobal(\"fetch\", vi.fn(async () => new Response(JSON.stringify({ ok: true }))) as any);\n});\n\nafterEach(() => {\n  vi.unstubAllGlobals();\n  vi.useRealTimers();\n  vi.restoreAllMocks();\n});\n\nit(\"polls once\", async () => {\n  const fetchSpy = fetch as any;\n  await fetch(\"/api/ping\");\n  expect(fetchSpy).toHaveBeenCalledTimes(1);\n});\n",
        "negative": "import { it, expect } from \"vitest\";\n\nit(\"sometimes passes\", async () => {\n  await new Promise((r) => setTimeout(r, 100));\n  const res = await fetch(\"/api/ping\");\n  expect(res.status).toBe(200);\n});\n",
        "language": "TYPESCRIPT"
      }
    }
  ]
}
