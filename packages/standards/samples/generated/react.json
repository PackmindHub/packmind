{
  "name": "React Best Practices",
  "summary": "A production-focused React standard for preventing common state, effect, rendering, and data-fetching pitfalls in apps with real users and real latency.",
  "description": "This standard covers high-impact React patterns around effects, concurrency, async work, state ownership, rendering performance, input handling, and boundaries between UI and side effects.",
  "scope": "**/*.tsx,**/*.jsx,**/*.ts,**/*.js",
  "rules": [
    {
      "content": "Guard async effects with AbortController and ignore stale responses before setting state.",
      "examples": {
        "positive": "import * as React from \"react\";\n\ntype User = { id: string; name: string };\n\nexport function UserPanel({ userId }: { userId: string }) {\n  const [user, setUser] = React.useState<User | null>(null);\n  const [error, setError] = React.useState<string | null>(null);\n\n  React.useEffect(() => {\n    const ac = new AbortController();\n\n    (async () => {\n      try {\n        setError(null);\n        const res = await fetch(`/api/users/${userId}`, { signal: ac.signal });\n        if (!res.ok) throw new Error(`HTTP ${res.status}`);\n        const data: User = await res.json();\n        if (!ac.signal.aborted) setUser(data);\n      } catch (e) {\n        if (!ac.signal.aborted) setError(String(e));\n      }\n    })();\n\n    return () => ac.abort();\n  }, [userId]);\n\n  if (error) return <div role=\"alert\">{error}</div>;\n  return <div>{user ? user.name : \"Loading...\"}</div>;\n}\n",
        "negative": "import * as React from \"react\";\n\ntype User = { id: string; name: string };\n\nexport function UserPanel({ userId }: { userId: string }) {\n  const [user, setUser] = React.useState<User | null>(null);\n\n  React.useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then((r) => r.json())\n      .then(setUser);\n  }, [userId]);\n\n  return <div>{user ? user.name : \"Loading...\"}</div>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Specify complete Hook dependency arrays and extract stable callbacks with useCallback or inline them inside the effect.",
      "examples": {
        "positive": "import * as React from \"react\";\n\ntype User = { id: string; name: string };\n\nexport function Search() {\n  const [q, setQ] = React.useState(\"\");\n  const [rows, setRows] = React.useState<User[]>([]);\n\n  const run = React.useCallback(async (query: string) => {\n    const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`);\n    setRows(await res.json());\n  }, []);\n\n  React.useEffect(() => {\n    if (!q) return;\n    run(q);\n  }, [q, run]);\n\n  return (\n    <>\n      <input value={q} onChange={(e) => setQ(e.target.value)} />\n      <pre>{JSON.stringify(rows, null, 2)}</pre>\n    </>\n  );\n}\n",
        "negative": "import * as React from \"react\";\n\ntype User = { id: string; name: string };\n\nexport function Search() {\n  const [q, setQ] = React.useState(\"\");\n  const [rows, setRows] = React.useState<User[]>([]);\n\n  const run = async (query: string) => {\n    const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`);\n    setRows(await res.json());\n  };\n\n  React.useEffect(() => {\n    if (!q) return;\n    run(q);\n  }, [q]);\n\n  return (\n    <>\n      <input value={q} onChange={(e) => setQ(e.target.value)} />\n      <pre>{JSON.stringify(rows, null, 2)}</pre>\n    </>\n  );\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Memoize Context provider values and callbacks; avoid passing freshly created objects/functions as Context value.",
      "examples": {
        "positive": "import * as React from \"react\";\n\ntype Theme = \"light\" | \"dark\";\n\ntype ThemeCtx = {\n  theme: Theme;\n  setTheme: (t: Theme) => void;\n};\n\nexport const ThemeContext = React.createContext<ThemeCtx | null>(null);\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = React.useState<Theme>(\"light\");\n\n  const value = React.useMemo(() => ({ theme, setTheme }), [theme]);\n\n  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;\n}\n",
        "negative": "import * as React from \"react\";\n\ntype Theme = \"light\" | \"dark\";\n\ntype ThemeCtx = {\n  theme: Theme;\n  setTheme: (t: Theme) => void;\n};\n\nexport const ThemeContext = React.createContext<ThemeCtx | null>(null);\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = React.useState<Theme>(\"light\");\n\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Keep derived data out of state; compute via useMemo or inline expressions from the source state and props.",
      "examples": {
        "positive": "import * as React from \"react\";\n\ntype Item = { id: string; name: string };\n\nexport function FilteredList({ items }: { items: Item[] }) {\n  const [q, setQ] = React.useState(\"\");\n\n  const filtered = React.useMemo(\n    () => items.filter((i) => i.name.toLowerCase().includes(q.toLowerCase())),\n    [items, q]\n  );\n\n  return (\n    <>\n      <input value={q} onChange={(e) => setQ(e.target.value)} />\n      <ul>{filtered.map((i) => <li key={i.id}>{i.name}</li>)}</ul>\n    </>\n  );\n}\n",
        "negative": "import * as React from \"react\";\n\ntype Item = { id: string; name: string };\n\nexport function FilteredList({ items }: { items: Item[] }) {\n  const [q, setQ] = React.useState(\"\");\n  const [filtered, setFiltered] = React.useState<Item[]>(items);\n\n  React.useEffect(() => {\n    setFiltered(items.filter((i) => i.name.toLowerCase().includes(q.toLowerCase())));\n  }, [items, q]);\n\n  return (\n    <>\n      <input value={q} onChange={(e) => setQ(e.target.value)} />\n      <ul>{filtered.map((i) => <li key={i.id}>{i.name}</li>)}</ul>\n    </>\n  );\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Normalize list keys to stable identifiers; avoid array index, Math.random(), or object references as keys.",
      "examples": {
        "positive": "import * as React from \"react\";\n\ntype Todo = { id: string; title: string };\n\nexport function Todos({ todos }: { todos: Todo[] }) {\n  return (\n    <ul>\n      {todos.map((t) => (\n        <li key={t.id}>{t.title}</li>\n      ))}\n    </ul>\n  );\n}\n",
        "negative": "import * as React from \"react\";\n\ntype Todo = { id: string; title: string };\n\nexport function Todos({ todos }: { todos: Todo[] }) {\n  return (\n    <ul>\n      {todos.map((t, i) => (\n        <li key={i}>{t.title}</li>\n      ))}\n    </ul>\n  );\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Prefer functional state updates when next state depends on previous state; avoid reading stale state from closures.",
      "examples": {
        "positive": "import * as React from \"react\";\n\nexport function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  const incTwice = () => {\n    setCount((c) => c + 1);\n    setCount((c) => c + 1);\n  };\n\n  return <button onClick={incTwice}>{count}</button>;\n}\n",
        "negative": "import * as React from \"react\";\n\nexport function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  const incTwice = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n\n  return <button onClick={incTwice}>{count}</button>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Wrap event handlers and effects with consistent error routing; avoid unhandled promise rejections from async handlers.",
      "examples": {
        "positive": "import * as React from \"react\";\n\nfunction reportError(e: unknown) {\n  console.error(e);\n}\n\nexport function SaveButton() {\n  const [saving, setSaving] = React.useState(false);\n\n  const onClick = async () => {\n    try {\n      setSaving(true);\n      const res = await fetch(\"/api/save\", { method: \"POST\" });\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\n    } catch (e) {\n      reportError(e);\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  return (\n    <button disabled={saving} onClick={() => void onClick()}>\n      Save\n    </button>\n  );\n}\n",
        "negative": "import * as React from \"react\";\n\nexport function SaveButton() {\n  const onClick = async () => {\n    await fetch(\"/api/save\", { method: \"POST\" });\n    throw new Error(\"boom\");\n  };\n\n  return <button onClick={onClick}>Save</button>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Isolate non-serializable resources in refs or module singletons; avoid storing AbortController, WebSocket, or timers in React state.",
      "examples": {
        "positive": "import * as React from \"react\";\n\nexport function SocketStatus() {\n  const wsRef = React.useRef<WebSocket | null>(null);\n  const [status, setStatus] = React.useState<\"idle\" | \"open\" | \"closed\">(\"idle\");\n\n  React.useEffect(() => {\n    const ws = new WebSocket(\"wss://example.com/stream\");\n    wsRef.current = ws;\n\n    ws.onopen = () => setStatus(\"open\");\n    ws.onclose = () => setStatus(\"closed\");\n\n    return () => {\n      ws.close();\n      wsRef.current = null;\n    };\n  }, []);\n\n  return <div>{status}</div>;\n}\n",
        "negative": "import * as React from \"react\";\n\nexport function SocketStatus() {\n  const [ws, setWs] = React.useState<WebSocket | null>(null);\n\n  React.useEffect(() => {\n    setWs(new WebSocket(\"wss://example.com/stream\"));\n  }, []);\n\n  return <div>{ws ? \"created\" : \"none\"}</div>;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Sanitize untrusted HTML before using dangerouslySetInnerHTML; avoid rendering raw user-provided HTML strings.",
      "examples": {
        "positive": "import * as React from \"react\";\nimport DOMPurify from \"dompurify\";\n\nexport function Comment({ html }: { html: string }) {\n  const safe = React.useMemo(() => DOMPurify.sanitize(html), [html]);\n  return <div dangerouslySetInnerHTML={{ __html: safe }} />;\n}\n",
        "negative": "import * as React from \"react\";\n\nexport function Comment({ html }: { html: string }) {\n  return <div dangerouslySetInnerHTML={{ __html: html }} />;\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    },
    {
      "content": "Define ErrorBoundary and Suspense boundaries near feature edges; avoid a single top-level boundary that obscures failing component context.",
      "examples": {
        "positive": "import * as React from \"react\";\n\nclass ErrorBoundary extends React.Component<\n  { fallback: React.ReactNode; children: React.ReactNode },\n  { hasError: boolean }\n> {\n  state = { hasError: false };\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n  render() {\n    return this.state.hasError ? this.props.fallback : this.props.children;\n  }\n}\n\nconst Reports = React.lazy(() => import(\"./Reports\"));\n\nexport function Dashboard() {\n  return (\n    <section>\n      <h1>Dashboard</h1>\n      <ErrorBoundary fallback={<div>Reports failed</div>}>\n        <React.Suspense fallback={<div>Loading reports...</div>}>\n          <Reports />\n        </React.Suspense>\n      </ErrorBoundary>\n    </section>\n  );\n}\n",
        "negative": "import * as React from \"react\";\n\nclass ErrorBoundary extends React.Component<\n  { fallback: React.ReactNode; children: React.ReactNode },\n  { hasError: boolean }\n> {\n  state = { hasError: false };\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n  render() {\n    return this.state.hasError ? this.props.fallback : this.props.children;\n  }\n}\n\nconst Reports = React.lazy(() => import(\"./Reports\"));\n\nexport function App() {\n  return (\n    <ErrorBoundary fallback={<div>Something broke</div>}>\n      <React.Suspense fallback={<div>Loading...</div>}>\n        <Reports />\n      </React.Suspense>\n    </ErrorBoundary>\n  );\n}\n",
        "language": "TYPESCRIPT_TSX"
      }
    }
  ]
}
