{
  "name": "Spring Best Practices",
  "description": "A focused standard for advanced Spring applications covering configuration, dependency injection, transactions, HTTP clients, validation, logging, async processing, and test reliability.",
  "scope": "Spring source files",
  "rules": [
    {
      "content": "Set explicit connect, read, and write timeouts on all RestTemplate or WebClient HTTP calls.",
      "examples": {
        "positive": "WebClient client = WebClient.builder()\n    .clientConnector(new ReactorClientHttpConnector(\n        HttpClient.create()\n            .responseTimeout(Duration.ofSeconds(3))\n            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 2000)))\n    .build();",
        "negative": "WebClient client = WebClient.create();\n\n// No timeouts configured, relies on defaults\nclient.get()\n    .uri(\"https://api.example.com/data\")\n    .retrieve()\n    .bodyToMono(String.class);",
        "language": "JAVA"
      }
    },
    {
      "content": "Use constructor injection for mandatory dependencies and avoid field injection in Spring components.",
      "examples": {
        "positive": "@Service\npublic class OrderService {\n\n    private final PaymentClient paymentClient;\n\n    public OrderService(PaymentClient paymentClient) {\n        this.paymentClient = paymentClient;\n    }\n}",
        "negative": "@Service\npublic class OrderService {\n\n    @Autowired\n    private PaymentClient paymentClient; // Field injection\n\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Declare transactional boundaries on Spring service methods only, avoiding @Transactional on controllers or repositories.",
      "examples": {
        "positive": "@Service\npublic class AccountService {\n\n    @Transactional\n    public void transfer(Long fromId, Long toId, BigDecimal amount) {\n        // load accounts, update balances, save\n    }\n}",
        "negative": "@RestController\npublic class AccountController {\n\n    @PostMapping(\"/transfer\")\n    @Transactional // Transaction on controller\n    public void transfer(@RequestBody TransferRequest request) {\n        // call service\n    }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Validate incoming request payloads with @Valid and method-level constraints at controller boundaries.",
      "examples": {
        "positive": "public class CreateUserRequest {\n    @NotBlank\n    private String username;\n\n    @Email\n    private String email;\n}\n\n@RestController\npublic class UserController {\n    @PostMapping(\"/users\")\n    public void create(@Valid @RequestBody CreateUserRequest request) {\n        // ...\n    }\n}",
        "negative": "public class CreateUserRequest {\n    public String username;\n    public String email;\n}\n\n@RestController\npublic class UserController {\n    @PostMapping(\"/users\")\n    public void create(@RequestBody CreateUserRequest request) {\n        // No validation annotations\n    }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Use immutable configuration properties bound with @ConfigurationProperties instead of scattered @Value injections.",
      "examples": {
        "positive": "@ConfigurationProperties(prefix = \"payment\")\npublic class PaymentProperties {\n    private String baseUrl;\n    private Duration timeout;\n    // getters and setters\n}\n\n@Configuration\n@EnableConfigurationProperties(PaymentProperties.class)\npublic class PaymentConfig {\n    // inject PaymentProperties\n}",
        "negative": "@Service\npublic class PaymentClient {\n\n    @Value(\"${payment.base-url}\")\n    private String baseUrl;\n\n    @Value(\"${payment.timeout}\")\n    private long timeoutMillis;\n\n    // Direct field-based configuration\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Log errors with structured context and propagate exceptions using consistent application-specific exception types.",
      "examples": {
        "positive": "@Service\npublic class InvoiceService {\n\n    private static final Logger log = LoggerFactory.getLogger(InvoiceService.class);\n\n    public Invoice load(String id) {\n        try {\n            return repository.findById(id)\n                .orElseThrow(() -> new InvoiceNotFoundException(id));\n        } catch (DataAccessException ex) {\n            log.error(\"Failed to load invoice\", kv(\"invoiceId\", id), ex);\n            throw new InvoiceAccessException(id, ex);\n        }\n    }\n}",
        "negative": "@Service\npublic class InvoiceService {\n\n    private static final Logger log = LoggerFactory.getLogger(InvoiceService.class);\n\n    public Invoice load(String id) {\n        try {\n            return repository.findById(id).get();\n        } catch (Exception e) {\n            log.error(\"Error\", e); // No context\n            return null; // Swallowed\n        }\n    }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Avoid mutable shared state in Spring beans; keep state per request, per method, or explicitly synchronized.",
      "examples": {
        "positive": "@Service\npublic class ReportService {\n\n    public Report generate(ReportRequest request) {\n        ReportBuilder builder = new ReportBuilder(); // local state\n        return builder.build(request);\n    }\n}",
        "negative": "@Service\n@Scope(\"singleton\")\npublic class ReportService {\n\n    private final ReportBuilder sharedBuilder = new ReportBuilder(); // shared mutable state\n\n    public Report generate(ReportRequest request) {\n        sharedBuilder.reset();\n        return sharedBuilder.build(request);\n    }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Use message converters and HttpMessageReader/Writer configuration instead of manual JSON parsing in controllers or filters.",
      "examples": {
        "positive": "@RestController\npublic class OrderController {\n\n    @PostMapping(\"/orders\")\n    public OrderResponse create(@RequestBody OrderRequest request) {\n        // Spring handles JSON conversion\n        return service.create(request);\n    }\n}\n\n@Configuration\npublic class WebConfig implements WebFluxConfigurer {\n    @Override\n    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n        configurer.defaultCodecs().maxInMemorySize(256 * 1024);\n    }\n}",
        "negative": "@RestController\npublic class OrderController {\n\n    private final ObjectMapper mapper = new ObjectMapper();\n\n    @PostMapping(\"/orders\")\n    public String create(HttpServletRequest request) throws IOException {\n        OrderRequest order = mapper.readValue(request.getInputStream(), OrderRequest.class); // manual parsing\n        OrderResponse response = service.create(order);\n        return mapper.writeValueAsString(response);\n    }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Configure retry policies externally using Spring Retry or Resilience4j instead of manual loop-based retries around remote calls.",
      "examples": {
        "positive": "@Service\npublic class BillingClient {\n\n    @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 200))\n    public Invoice fetchInvoice(String id) {\n        // remote call\n    }\n}\n\n@EnableRetry\n@Configuration\npublic class RetryConfig { }",
        "negative": "@Service\npublic class BillingClient {\n\n    public Invoice fetchInvoice(String id) {\n        int attempts = 0;\n        while (attempts < 3) {\n            try {\n                return doRemoteCall(id);\n            } catch (IOException ex) {\n                attempts++;\n            }\n        }\n        throw new RuntimeException(\"failed\");\n    }\n}",
        "language": "JAVA"
      }
    },
    {
      "content": "Use @SpringBootTest with slice tests and embedded test doubles instead of hitting real external services or databases.",
      "examples": {
        "positive": "@WebMvcTest(UserController.class)\nclass UserControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService; // test double\n}\n\n@DataJpaTest\nclass UserRepositoryTest {\n\n    @Autowired\n    private TestEntityManager em; // embedded database\n}",
        "negative": "@SpringBootTest\nclass UserControllerIT {\n\n    @Test\n    void callsRealServiceAndDatabase() {\n        // Starts full context\n        // Uses real external URLs and real database\n    }\n}",
        "language": "JAVA"
      }
    }
  ]
}
