{
  "name": "Terraform Best Practices",
  "summary": "Advanced Terraform rules for writing safe, predictable, and maintainable infrastructure code across modules, environments, and CI/CD pipelines.",
  "description": "This standard covers high-impact Terraform patterns around planning determinism, state safety, module interfaces, secret handling, lifecycle controls, and provider/resource behaviors that commonly cause production incidents or drift.",
  "scope": "**/*.tf",
  "rules": [
    {
      "content": "Pin required_version and each required_providers version; avoid unbounded constraints and provider source omissions.",
      "examples": {
        "positive": "terraform {\n  required_version = \"~> 1.7.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.40\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~> 3.6\"\n    }\n  }\n}\n",
        "negative": "terraform {\n  required_providers {\n    aws = {\n      version = \">= 0.0.0\"\n    }\n  }\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Use stable map/set keys for for_each; avoid keys derived from unknown values, timestamps, or random data.",
      "examples": {
        "positive": "variable \"subnets\" {\n  type = map(object({\n    cidr = string\n    az   = string\n  }))\n}\n\nresource \"aws_subnet\" \"this\" {\n  for_each = var.subnets\n\n  vpc_id            = aws_vpc.this.id\n  cidr_block        = each.value.cidr\n  availability_zone = each.value.az\n\n  tags = {\n    Name = \"subnet-${each.key}\"\n  }\n}\n",
        "negative": "resource \"aws_subnet\" \"this\" {\n  for_each = toset([for s in data.aws_availability_zones.available.names : \"${s}-${timestamp()}\" ])\n\n  vpc_id     = aws_vpc.this.id\n  cidr_block = \"10.0.0.0/24\"\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Prefer precondition/postcondition for invariants; avoid burying validation in count/for_each expressions or null_resource hacks.",
      "examples": {
        "positive": "resource \"aws_security_group\" \"app\" {\n  name   = var.name\n  vpc_id = var.vpc_id\n\n  lifecycle {\n    precondition {\n      condition     = length(var.allowed_cidrs) > 0\n      error_message = \"allowed_cidrs must be non-empty\"\n    }\n  }\n}\n",
        "negative": "resource \"aws_security_group\" \"app\" {\n  count  = length(var.allowed_cidrs) > 0 ? 1 : 0\n  name   = var.name\n  vpc_id = var.vpc_id\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Declare explicit depends_on when provider API ordering matters; avoid relying on implicit graph behavior through string interpolation side effects.",
      "examples": {
        "positive": "resource \"aws_iam_role\" \"role\" {\n  name               = var.role_name\n  assume_role_policy = data.aws_iam_policy_document.assume.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"attach\" {\n  role       = aws_iam_role.role.name\n  policy_arn = var.policy_arn\n\n  depends_on = [aws_iam_role.role]\n}\n",
        "negative": "resource \"aws_iam_role\" \"role\" {\n  name               = var.role_name\n  assume_role_policy = data.aws_iam_policy_document.assume.json\n}\n\nresource \"aws_iam_role_policy_attachment\" \"attach\" {\n  role       = \"${aws_iam_role.role.name}\"\n  policy_arn = var.policy_arn\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Use lifecycle ignore_changes only for documented, bounded fields; avoid blanket ignore_changes = all and ignoring identity-critical attributes.",
      "examples": {
        "positive": "resource \"aws_autoscaling_group\" \"this\" {\n  name                = var.name\n  desired_capacity    = var.desired_capacity\n  max_size            = var.max_size\n  min_size            = var.min_size\n  vpc_zone_identifier = var.subnet_ids\n\n  tag {\n    key                 = \"Name\"\n    value               = var.name\n    propagate_at_launch = true\n  }\n\n  lifecycle {\n    ignore_changes = [desired_capacity]\n  }\n}\n",
        "negative": "resource \"aws_autoscaling_group\" \"this\" {\n  name                = var.name\n  desired_capacity    = var.desired_capacity\n  max_size            = var.max_size\n  min_size            = var.min_size\n  vpc_zone_identifier = var.subnet_ids\n\n  lifecycle {\n    ignore_changes = all\n  }\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Mark sensitive inputs and outputs as sensitive; avoid exposing secrets via outputs, locals, tags, or plan-time string concatenation.",
      "examples": {
        "positive": "variable \"db_password\" {\n  type      = string\n  sensitive = true\n}\n\nresource \"aws_db_instance\" \"this\" {\n  identifier = var.name\n  engine     = \"postgres\"\n\n  username = var.db_username\n  password = var.db_password\n}\n\noutput \"db_password\" {\n  value     = var.db_password\n  sensitive = true\n}\n",
        "negative": "variable \"db_password\" {\n  type = string\n}\n\noutput \"db_password\" {\n  value = var.db_password\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Choose one state isolation strategy per system; avoid shared state across environments without separate backends or workspaces.",
      "examples": {
        "positive": "terraform {\n  backend \"s3\" {\n    bucket         = \"acme-tfstate\"\n    key            = \"prod/network/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"acme-tf-locks\"\n    encrypt        = true\n  }\n}\n",
        "negative": "terraform {\n  backend \"s3\" {\n    bucket = \"acme-tfstate\"\n    key    = \"shared/terraform.tfstate\"\n    region = \"us-east-1\"\n  }\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Avoid data sources for values managed in the same configuration; reference resources/outputs directly instead of re-discovering them.",
      "examples": {
        "positive": "resource \"aws_security_group\" \"app\" {\n  name   = \"app\"\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_instance\" \"web\" {\n  ami                    = var.ami\n  instance_type          = \"t3.micro\"\n  vpc_security_group_ids = [aws_security_group.app.id]\n  subnet_id              = aws_subnet.public.id\n}\n",
        "negative": "resource \"aws_security_group\" \"app\" {\n  name   = \"app\"\n  vpc_id = aws_vpc.main.id\n}\n\ndata \"aws_security_group\" \"app\" {\n  name   = \"app\"\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_instance\" \"web\" {\n  ami                    = var.ami\n  instance_type          = \"t3.micro\"\n  vpc_security_group_ids = [data.aws_security_group.app.id]\n  subnet_id              = aws_subnet.public.id\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Guard against unknown/absent optional values using try() and null-aware patterns; avoid direct indexing into optional objects and maps.",
      "examples": {
        "positive": "variable \"tags\" {\n  type    = map(string)\n  default = {}\n}\n\nlocals {\n  owner = try(var.tags[\"owner\"], null)\n}\n\nresource \"aws_s3_bucket\" \"this\" {\n  bucket = var.bucket_name\n\n  tags = merge(\n    var.tags,\n    local.owner == null ? {} : { owner = local.owner }\n  )\n}\n",
        "negative": "variable \"tags\" {\n  type    = map(string)\n  default = {}\n}\n\nresource \"aws_s3_bucket\" \"this\" {\n  bucket = var.bucket_name\n  tags   = { owner = var.tags[\"owner\"] }\n}\n",
        "language": "GENERIC"
      }
    },
    {
      "content": "Separate computed inputs from direct resource arguments by using locals; avoid duplicating expressions across resources and modules.",
      "examples": {
        "positive": "locals {\n  common_tags = merge(\n    var.tags,\n    {\n      service     = var.service\n      environment = var.environment\n    }\n  )\n}\n\nresource \"aws_s3_bucket\" \"logs\" {\n  bucket = \"${var.service}-${var.environment}-logs\"\n  tags   = local.common_tags\n}\n\nresource \"aws_cloudwatch_log_group\" \"app\" {\n  name = \"/${var.service}/${var.environment}\"\n  tags = local.common_tags\n}\n",
        "negative": "resource \"aws_s3_bucket\" \"logs\" {\n  bucket = \"${var.service}-${var.environment}-logs\"\n  tags = merge(var.tags, {\n    service     = var.service\n    environment = var.environment\n  })\n}\n\nresource \"aws_cloudwatch_log_group\" \"app\" {\n  name = \"/${var.service}/${var.environment}\"\n  tags = merge(var.tags, {\n    service     = var.service\n    environment = var.environment\n  })\n}\n",
        "language": "GENERIC"
      }
    }
  ]
}
